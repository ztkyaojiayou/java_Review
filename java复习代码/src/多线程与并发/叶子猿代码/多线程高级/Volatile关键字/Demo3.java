package 多线程与并发.叶子猿代码.多线程高级.Volatile关键字;

/**
 * volatile变量的可见性的原理：
 *（1）首先，java内存模型中，每个线程有⾃⼰的⼯作内存，同时还有⼀个共享的主内存。
 * ⽐如说有两个线程，他们的代码⾥都需要读取data这个变量的值，那么他们就都会从主内存⾥加载data变量的值到⾃⼰的⼯作内存，然后才可以使⽤那个值。
 * 这样⼀来，线程的代码在执⾏过程中，就可以直接从⾃⼰本地缓存⾥加载变量副本，不需要从主内存加载变量值，性能可以提升很多！
 *（2）原理：
 * 第⼀，⼀旦data变量定义的时候前⾯加了volatile来修饰的话，那么线程1只要修改data变量的值，
 * 就会在修改完⾃⼰本地⼯作内存的data变量值之后，
 * 强制将这个data变量最新 的值刷回主内存，必须让主内存⾥的data变量值⽴⻢变成最新的值！
 * 第⼆，如果此时别的线程的⼯作内存中有这个data变量的本地缓存，也就是⼀个变量副本的话，
 * 那么会强制让其他线程的⼯作内存中的data变量缓存直接失效过期，不允许再次读 取和使⽤了！
 * 第三，如果线程2在代码运⾏过程中再次需要读取data变量的值，此时尝试从本地⼯作内存中读取，就会发现这个data = 0已经过期了！
 * 此时，他就必须重新从主内存中加载data变量最新的值！那么不就可以读取到data = 1这 个最新的值了！
 *（3）小总结：
 * 对⼀个变量加了volatile关键字修饰之后，只要⼀个线程修改了这个变量的值，⽴⻢强制刷回主内存。
 * 接着强制过期其他线程的本地⼯作内存中的缓存，最后其他线程读取变量值的时候，强制重新从主内存来加载最新的值！
 * 这样就保证，任何⼀个线程修改了变量值，其他线程⽴⻢就可以看⻅了。
 * 这就是所谓的volatile保证了可⻅性的⼯作原理！
 *
 * 写：当写一个volatile变量时，Java内存模型会把该线程对应的本地内存中的共享变量值刷新到主内存中
 * 读：当读一个volatile变量时，Java内存模型会把当前线程对应的本地内存中的共享变量置为无效，然后从主内存中读取最新的共享变量。
 *
 */


public class Demo3 {

    private int a;
    private volatile boolean flag;

    public void writer () {
        a = 1; // 1
        flag = true; // 2   当写一个volatile变量时，Java内存模型会把该线程对应的本地内存中的共享变量值刷新到主内存中
    }

    public void reader () {
        if(flag) { // 3 当读一个volatile变量时，Java内存模型会把当前线程对应的本地内存中的共享变量置为无效，然后从主内存中读取共享变量。
            int b = a + 1; // 4
            System.out.println(b); // 5
        }
    }

}
