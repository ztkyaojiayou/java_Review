package java基础.成员变量和局部变量;

public class test06成员变量 {

        static int s;//成员变量，由于有static修饰，所以也叫类变量，其全局共享，存在方法区的常量池中
        int i;//成员变量（实例变量），创建对象时会被存入堆中，有默认初始值（0）
        int j;//成员变量（实例变量），同上

        //（非静态）代码块中的全为局部变量，没有默认初始值，只在此代码块中有效，
        // 且每次创建对象时都会执行一次，则成员变量j和静态变量s都要加一
        //（局部变量i也一样，只不过当方法执行完毕后就会被销毁，所以不是我们关心的重点）
        {
            int i = 1;//局部变量
            i++;//就近原则，就是此代码块中的i
            j++;//成员变量，每次创建对象时都要加1
            s++;//静态变量，每次创建对象时都要加1
        }

    /**
     * 每次调用方法都会在栈中开辟一块空间，用于方法的执行，一旦执行完毕就会被释放，局部变量的值也同时会被释放
     * 此j非彼j，因为方法体中定义的变量都是局部变量（除非有this修饰）（注意：只有它单独定义的才是局部变量）
     * 每次调用时成员变量i和静态变量s都要加一（局部变量j也一样，只不过当方法执行完毕后就会被销毁，所以不是我们关心的重点）
     * @param j
     */
    public void test(int j){
            j++;//局部变量，但若为this.j，则为成员变量
            i++;//是成员变量i，因为此方法中并没有定义i
            s++;//静态变量，同上
        }

        public static void main(String[] args) {//形参，局部变量，args
            //obj1为对象的引用，存在栈中，对象则存入了堆中，且i和j均为0，但由于会执行代码块，
            //因此j会变为1（但i不会，因为是局部变量，只是在栈中加一而已）
            test06成员变量 obj1 = new test06成员变量();

            //同上，只不过是一个新对象，也会执行那段代码块，结果为i=0，j=1，相当于最终的初始值
            test06成员变量 obj2 = new test06成员变量();

            //调用test方法，此时会在栈中重新为此方法的执行开辟一块内存空间，
            //栈中的局部变量j变为11（但执行完就会被销毁，所以不重要），堆中的成员变量i变为1，不会被销毁
            obj1.test(10);

            //同理，只是此时会在栈中重新为此方法的执行开辟一块内存空间，
            //栈中的局部变量j变为21（但执行完也会被销毁，不重要），堆中的成员变量i变为2，j还是1，不会被销毁
            obj1.test(20);

            //同理，堆中的成员变量i变为1，j还是1（因为改变的只是局部变量里面的j，会被销毁）
            obj2.test(30);

            //经过上面的分析，结果便一目了然，直接去常量池和堆中去看就行了
            System.out.println(obj1.i + "," + obj1.j + "," + obj1.s);
            System.out.println(obj2.i + "," + obj2.j + "," + obj2.s);
        }
}
/**
 * 运行结果如下:
 * 2,1,5
 * 1,1,5
 */


