package 数据结构与算法.离职后刷题.第四遍必会版;

//有冷冻期，可交易多次
public class demo103_3动态规划之买卖股票_交易多次且有冷冻期III {
    /**
     * 定义两个状态：
     * (1)0: 表示当天不持有股票，于是dp[i][0]就表示：第i天不持有股票时的最大利润，此时就有两种情况：
     * 1）今天本来持有股票的，但是把它卖了：此时的利润就为：昨天持有股票时的利润+今天卖掉该股票的利润,即：
     * dp[i][0] = dp[i-1][1] + price[i]
     * 2）昨天就没有，而今天又啥也没干，所以此时的利润就为：昨天没有持有股票时的利润，即为：
     * dp[i][0] = dp[i-1][0]
     * 3)最后，再取二者的最大值即可
     * 4)易知，初始值即为：dp[0][0] = 0;
     * <p>
     * (2)1：表示当天持有股票，于是dp[i][1]就表示：第i天持有股票时的最大利润，此时也有两种情况：
     * 1）今天刚买的:则由于冷冻期的存在，一定是因为前天卖了一次股票，所以今天才可以买(负利润/成本），于是此时利润就可以表示为：
     * dp[i][1] = dp[i-2][0] - price[i]，即前一天卖了股票的利润-今天买入的成本
     * 2）昨天就有:于是今天就不能买，因为昨天的都还没有卖呀，所以今天的利润就是昨天的利润，于是此时利润就可以表示为：
     * dp[i][1] = dp[i-1][1]，即昨天还持有股票没卖时的利润
     * 3）最后，再取二者的最大值即可
     * 4)易知，初始值即为：dp[0][1] = 0 - price[0]，即自费买的第一支股票，即为成本;
     */
    public int maxProfit03(int[] nums) {
        // 一天就俩情况：持有股票和没持股票，分别计算每一天的这两个值即可，
        // 然后取最后一天这两个值的较大者即可
        //dp[i][0]就表示：第i天不持有股票时的最大利润
        //dp[i][1]就表示：第i天持有股票时的最大利润
        int len = nums.length;
        int[][] dp = new int[len][2];
        //表示第一天不持有股票时的利润，即没买，则利润为0
        dp[0][0] = 0;
        //表示第一天持有股票时的利润，即自费买的，那么此时所谓的利润就是成本呀
        dp[0][1] = -nums[0];
        //求每一天的情况，从上分析可知，每一天都分两种情况呀
        for (int i = 1; i < len; i++) {
            //昨天就没有或昨天持有今天刚卖，利润就为dp[i - 1][1]+nums[i]
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i]);
            //昨天就有或昨天没有今天刚买（此时利润就是dp[i-2]了，因为有冷冻期）
            dp[i][1] = Math.max(dp[i - 1][1], ((i - 2) >= 0 ? dp[i - 2][0] : -nums[i]));
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }

    //自写一遍
    public int maxProfit003(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = -nums[0];
        for (int i = 1; i < len; i++) {
            //当前没持有股票
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i]);
            //当天持有股票
            dp[i][1] = Math.max(dp[i - 1][1], ((i - 2) >= 0 ? dp[i - 2][0] : -nums[i]));
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }
}
