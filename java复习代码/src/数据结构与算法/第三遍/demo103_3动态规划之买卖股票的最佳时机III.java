package 数据结构与算法.第三遍;

import java.util.ArrayList;

//有冷冻期，可交易多次
public class demo103_3动态规划之买卖股票的最佳时机III {
    /**
     * 定义两个状态：
     * (1)0: 表示当天不持有股票，于是dp[i][0]就表示：第i天不持有股票时的最大利润，此时就有两种情况：
     *    1）今天本来持有股票的，但是把它卖了：此时的利润就为：昨天持有股票时的利润+今天卖掉该股票的利润,即：
     *    dp[i][0] = dp[i-1][1] + price[i]
     *    2）昨天就没有，而今天又啥也没干，所以此时的利润就为：昨天没有持有股票时的利润，即为：
     *    dp[i][0] = dp[i-1][0]
     *    3)最后，再取二者的最大值即可
     *    4)易知，初始值即为：dp[0][0] = 0;
     *
     * (2)1：表示当天持有股票，于是dp[i][1]就表示：第i天持有股票时的最大利润，此时也有两种情况：
     *    1）今天刚买的:则由于冷冻期的存在，一定是因为前天卖了一次股票，所以今天才可以买(负利润/成本），于是此时利润就可以表示为：
     *       dp[i][1] = dp[i-2][0] - price[i]，即前一天卖了股票的利润-今天买入的成本
     *    2）昨天就有:于是今天就不能买，因为昨天的都还没有卖呀，所以今天的利润就是昨天的利润，于是此时利润就可以表示为：
     *       dp[i][1] = dp[i-1][1]，即昨天还持有股票没卖时的利润
     *    3）最后，再取二者的最大值即可
     *    4)易知，初始值即为：dp[0][1] = 0 - price[0]，即自费买的第一支股票，即为成本;
     */
    public int maxProfit03(int[] nums) {
        //dp[i][0]就表示：第i天不持有股票时的最大利润
        //dp[i][1]就表示：第i天持有股票时的最大利润
        int[][] dp = new int[nums.length][2];
        dp[0][0] = 0;
        dp[0][1] = 0-nums[0];//相当于自费买
        for (int i = 1;i<nums.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+nums[i]);//昨天就没有或昨天持有今天刚卖，利润就为nums[i]
            dp[i][1] = Math.max(dp[i-1][1],((i-2) >= 0 ? dp[i-2][0]:0 -nums[i]));//昨天就有或昨天没有今天刚买
        }
        return Math.max(dp[nums.length-1][0],dp[nums.length-1][1]);
    }
}
