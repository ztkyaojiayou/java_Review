package 数据结构与算法.第三遍;

/**
 *  * 338. 比特位计数
 *  * 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，（易知，遍历即可）
 *  * 计算其二进制数中的 1 的数目并将它们作为数组返回。
 */

/**
 * 解法：使用动态规划，但要了解一些基本的二进制知识
 * 设dp[i]为i的二进制形式的1的个数，则易知有两种情况：
 * （1）i是奇数时，dp[i]=dp[i-1]+1，因为i就是在二进制形式的i-1上加了个1呀；
 * （2）i是偶数时，dp[i]=dp[i/2]，因为i就是把二进制形式的i/2往左移（末尾补0）得到的，所以1的个数没变。
 *
 */
public class demo98_动态规划之整数序列的各位二进制位中的1的个数 {
    public int[] countBits(int num) {
        //dp[i] 表示数字i的二进制数中的 1 的数目
        int[] dp = new int[num + 1];
        dp[0] = 0;
        for (int i = 1; i < num + 1; i++) {
            if (i % 2 == 1) {//为奇数时
                dp[i] = dp[i - 1] + 1;
            } else {//为偶数时
                dp[i] = dp[i / 2];
            }
        }

        //最后，返回该dp数组即可
        return dp;
    }
}
