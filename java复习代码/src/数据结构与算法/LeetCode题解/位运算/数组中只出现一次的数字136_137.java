package 数据结构与算法.LeetCode题解.位运算;

/**
 * 136. 只出现一次的数字(入门级）
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。
 * 找出那个只出现了一次的元素。
 *
 * 说明：
 * 你的算法应该具有线性时间复杂度。
 * 你可以不使用额外空间来实现吗？
 *
 * 示例 1:
 * 输入: [2,2,1]
 * 输出: 1
 *
 * 示例 2:
 * 输入: [4,1,2,1,2]
 * 输出: 4
 */

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * 思路解析：
 *（1）如果没有复杂度的限制，本题可以有多种方法，比如：
 * 1）先排序，再遍历
 * 2）使用hashMap做字典映射
 * 3）使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，
 *    如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。
 * 4) 使用set集合存储数组中出现的所有数字，并计算数组中的元素之和。
 * 由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素(包括那个只出现一次的元素）出现两次的情况下的元素之和。
 * 由于数组中只有一个元素出现一次，其余元素都出现两次，
 * 因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。
 *
 *（2）但是本题要求时间复杂度为线性，且不能使用额外空间，因此只能另寻它法。
 * 本题可以使用位运算中的亦或（亦或符号为^=）来解决，非常巧妙。
 * 先看一下亦或的常用性质：
 *   1）任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0 = a。
 *   2）任何数和其自身做异或运算，结果是 0，即 a⊕a = 0。
 *   3）异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0 = b。
 *
 * 具体思路：
 * 现在假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。
 * 令 a1,a2,...am​为出现两次的 m 个数，am+1​为出现一次的数。
 * 根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：
 * (a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(am⊕am)⊕am+1
 * 再根据性质 2 和性质 1，上式又可化简和计算得到如下结果：
 * 0⊕0⊕⋯⊕0⊕am+1=am+1
 * 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。（核心关键）
 *
 * 复杂度分析
 * 时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
 * 空间复杂度：O(1)。
 *
 */
class 数组中只出现一次的数字136 {
        public int singleNumber(int[] nums) {
            int single_num = 0;//结果变量，且根据性质1，任何数和0亦或不改变结果，因此初始值为0也不影响最终结果
            for (int num : nums) {//遍历数组，做亦或运算
                single_num ^= num;
            }
            //最终亦或的结果即为只出现一次的数字，完美~
            return single_num;
        }
}

    /**
     * 137. 只出现一次的数字 II（进阶版）
     * 给定一个非空整数数组，除了某个元素只出现一次以外，
     * （区别）其余每个元素均出现了三次。
     * 找出那个只出现了一次的元素。
     *
     * 说明：
     * 你的算法应该具有线性时间复杂度。
     * 你可以不使用额外空间来实现吗？
     *
     * 示例 1:
     * 输入: [2,2,3,2]
     * 输出: 3
     *
     * 示例 2:
     * 输入: [0,1,0,1,0,1,99]
     * 输出: 99
     */

    /**
     * 思路解析：和上面一题类似，只不过其他元素均出现了三次而已，思路也相同
     * 可以使用hash表，排序再遍历，hashSet存值再做加减法，但是时间复杂度和空间复杂度不符合题意；
     * 因此也需要使用到位运算。
     *
     */

/**
 *方法1：使用hashSet存值（去自动重复），再做加减法即可
 * 将输入数组存储到 HashSet，然后使用 HashSet 中数字和的三倍与数组之和比较，
 * 3×(a+b+c)−(a+a+a+b+b+b+c)=2c
 * 易知，只出现一次的那个数字即为该减法运算之后的结果的一半。
 *
 * 复杂度分析
 * 时间复杂度：O(N)，遍历输入数组。
 * 空间复杂度：O(N)，存储 N/3 个元素的集合。
 */
class Solution137_1 {
    public int singleNumber(int[] nums) {
        Set<Long> set = new HashSet<>();
        //1.先定义两个和变量
        //其中sumSet为hashSet中的元素和，sumArray为数组元素和
        long sumSet = 0, sumArray = 0;
        for(int n : nums) {//2.再遍历数组，计算数组元素和，同时把数组元素存入set中（不包含重复元素）
            sumArray += n;
            set.add((long)n);
        }
        //3.再计算hashSet的元素和
        for(Long s : set) sumSet += s;
        //4.最后就可以得到结果啦，即为：（HashSet中的三倍和-数组和）/ 2
        return (int)((3 * sumSet - sumArray) / 2);
    }
}

/**
 * 方法2：使用hashMap做字典映射
 *
 * 复杂度分析
 * 时间复杂度：O(N)，遍历输入数组。
 * 空间复杂度：O(N)，存储 N/3 个元素的 Set。
 */
class Solution137_2 {
    public int singleNumber(int[] nums) {
        //1.使用一个map来做哈希映射，key为数组元素，value为其出现的次数
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums){
            //map.put(num, map.getOrDefault(num, 0) + 1);//骚操作，一句话就搞定，
            // 即：如果map中含有指定的key（即num），就返回该key对应的value，否则使用该方法的第二个参数0作为value返回
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        //2.再遍历map中的key（即数组中的元素）
        //2.1找到其value（即各元素出现的次数）为1的key即为所求
        for (int k : map.keySet()){
            if (map.get(k) == 1)
                return k;
        }
        //2.2若没有找到，则返回-1即可
        return -1;
    }
}

/**
 *方法3：使用位运算
 * 假如例子是 1 2 6 1 1 2 2 3 3 3, 即有3 个 1, 3 个 2, 3 个 3,1 个 6，将他们全部转化为二进制形式有：
 * 1 0 0 1
 * 2 0 1 0
 * 6 1 1 0
 * 1 0 0 1
 * 1 0 0 1
 * 2 0 1 0
 * 2 0 1 0
 * 3 0 1 1
 * 3 0 1 1
 * 3 0 1 1
 * 看最右边的一列 1001100111 有 6 个 1
 * 再往前看一列 0110011111 有 7 个 1
 * 再往前看一列 0010000 有 1 个 1
 * 我们只需把1的个数是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1
 * 也就是 1 1 0,也就是 6。
 *
 * 为什么呢？
 * 因为如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。
 * 之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。
 * 所以所有不是 3 的倍数的列写 1，其他列写 0 ，就找到了这个出现 1 次的数。
 */
class Solution137_3 {
    public int singleNumber(int[] nums) {
        int result = 0;
        //1.先统计1的个数
        //考虑每一位
        for (int i = 0; i < 32; i++) {
            int count = 0;
            //考虑每一个数
            for (int j = 0; j < nums.length; j++) {
                //当前位是否是 1
                if ((nums[j] >>> i & 1) == 1) {
                    count++;
                }
            }
            //2.再看 1 的个数是否是 3 的倍数，只考虑不为3的倍数即可
            if (count % 3 != 0) {
                result = result | 1 << i;
            }
        }
        return result;
    }
    }