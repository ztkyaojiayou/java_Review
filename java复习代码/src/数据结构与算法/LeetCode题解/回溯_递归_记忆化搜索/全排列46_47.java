package 数据结构与算法.LeetCode题解.回溯_递归_记忆化搜索;

import java.lang.reflect.Array;
import java.util.*;
import java.util.Arrays;
import java.util.List;
/**
 * 46. 全排列(入门版）
 * 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
 *
 * 示例:
 * 输入: [1,2,3]
 * 输出:
 * [
 *   [1,2,3],
 *   [1,3,2],
 *   [2,1,3],
 *   [2,3,1],
 *   [3,1,2],
 *   [3,2,1]
 * ]
 */


/**
 *解析：使用递归算法
 * （1）思路：
 * “全排列”就是一个非常经典的“回溯”算法的应用。我们知道，N 个数字的全排列一共有 N! 这么多个。
 * 大家可以尝试一下在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。
 *
 * 以数组 [1, 2, 3] 的全排列为例。
 * 我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；
 * 再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；
 * 最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。
 * 我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。
 * 按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。
 *
 * 在枚举第一位的时候，有 3 种情况。
 * 在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；
 * 在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。
 *
 * （2）下面我们解释如何写代码：
 * 1、首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提，
 * 我们需要在剩下还没有选择的数中按照顺序依次选择一个数，这显然是一个递归结构；
 *
 * 2、递归的终止条件是，数已经选够了，因此我们需要一个变量来表示当前递归到第几层，我们把这个变量叫做 depth；
 *
 * 3、这些结点实际上表示了搜索（查找）全排列问题的不同阶段，为了区分这些不同阶段，
 * 我们就需要一些变量来记录为了得到一个全排列，程序进行到哪一步了，在这里我们需要两个变量：
 *
 * （1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列；
 * （2）一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，
 * 当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，
 * 这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。
 *
 * 我们把这两个变量称之为“状态变量”，它们表示了我们在求解一个问题的时候所处的阶段。
 *
 * 4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。
 *
 * 5、另外，因为是执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，
 * 需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子。
 *
 * 从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，
 * 需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，
 * 因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。（这就是为什么我们需要删除最后一个元素的原因啦）
 * 这种在遍历的过程中，从深层结点回到浅层结点的过程中所做的操作就叫“回溯”。
 */
class 全排列46 {
    //定义结果集list，里面包含的是一个一个的小list，每一个都代表一种排列
    List<List<Integer>> results = new LinkedList<>();
    List<List<Integer>> permute(int[] nums) {
        // 记录「路径」，即每一个小的list
        LinkedList<Integer> path = new LinkedList<>();
        //开始调用递归方法
        backtrack(nums, path,0);
        //最后，返回结果即可
        return results;
    }

    /**
     * 具体的递归方法（注意，在递归中，没有"初始条件"一说，只有"递归结束的条件"一说）
     * @param nums  即提给的没有重复数字的数字序列
     * @param path 用于记录每一种符合题意的结果/路径
     */
    void backtrack(int[] nums, LinkedList<Integer> path,int start) {
        // 1.开始递归的四部曲：
        //（1）终止递归的条件，即当nums 中的元素全都在 path 中出现时,即已经是一个全排列时
        //其实也就是每一次递归结束的最后一步，即把结果存起来（重点）
        if (path.size() == nums.length) {
            results.add(new LinkedList(path));
            return;
        }
        // 2.开始递归
        for (int i = 0; i < nums.length; i++) {
            // 2.1排除不合法的选择,即当为重复元素时，就跳过该元素
            if (path.contains(nums[i])){
                continue;
            }
            //（2）2.2做选择，即在nums 中选择一个list中不存在的元素（即不能有重复数字）并记录到list中
            path.add(nums[i]);
            //（3）进入下一层决策树/递归
            backtrack(nums, path,i+1);
            //（4）取消选择（即删除最后一个元素，往上回溯/递归）
            path.removeLast();
        }
    }
}



/**
 * 47. 全排列 II（进阶版）
 * 给定一个可包含重复数字的序列，返回所有不重复的全排列。
 *
 * 示例:
 * 输入: [1,1,2]
 * 输出:
 * [
 *   [1,1,2],
 *   [1,2,1],
 *   [2,1,1]
 * ]
 */

/**
 * 解析：也是使用递归/回溯算法
 * （1）本题的基本框架依旧和46. 全排列是一样的，但是加了附加条件，需要做一下剪枝。
 * 其中最关键的点就是：在递归之前做选择，在递归之后撤销选择。
 * 由于本题需要返回所有不重复的全排列，有限制条件，所以需要进行剪枝。这里第一步先要给数组进行排序。
 * 首先，先要给nums进行排序，这样的做目的是方便剪枝
 * 其次，我们已经选择过的不需要再放进去了
 * 接下来，如果当前节点与他的前一个节点一样，并其他的前一个节点已经被遍历过了，那我们也就不需要了。
 *
 * （2）首先，得先明确重复是个什么情况呢？（我们来看下面的这个例子）
 * 对于46题而言,如果输入的是[1,2,3]，那么我们得到的结果是不重复的全排列
 * 也就是 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
 *
 * 但是如果输入的是[1,1,2]的话，因为我们没有对于重复的判断，所以得到的是以下结果
 * [[1, 1, 2], [1, 2, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 1, 1]]
 * 这明显是不符合题意的,其中[1,1,2],[1,1,2]和[1,2,1],[1,2,1]和[2,1,1]，[2,1,1]明显都是重复了一次。
 * 正确的输出应该是[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
 *
 * 这就意味着，我们只需要对46题目对应的算法做出相应的去重改进即可
 * 具体有以下步骤：
 * 加入 if (!used[i] && (nums[i]!=preNum))
 * （这部分的意义可以解释为：如果当前的这个数（即nums[i]）跟之前的数组中的数即preNum不相等，
 * 那才能说当前的nums[i]是一个有效的数字
 * 那么怎么才能保证preNum是一个不同的数呢？
 * （这里我们对数组初始进行了排序，Arrays.sort(nums);,
 * 这步保证了preNum一定是一个等于或者小于nums[i]的数，
 * 这也就是达到了去重的效果）

 */
class 全排列47 {
    //1.先定义一个结果集list，用于存储所有的结果集
    public List<List<Integer>> result = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        int len = nums.length;
        //2.首先给数组排序
        Arrays.sort(nums);
        //3.记录/存储每一个排列
        ArrayList<Integer> path = new ArrayList<>();
        //4.记录当前元素是否已经被访问过
        boolean[] visited = new boolean[len];
        //5.开始调用回溯/递归方法
        backtrack(nums,path,visited);
        //6.返回结果集
        return result;
    }

    /**
     * 具体的回溯/递归方法
     * @param nums 即题给的可包含重复数字的数字序列
     * @param visited 定义的一个boolean型的数组，长度和数组的长度系统，
     *                用于表示：若该数字已经被选过，则（要修改）为true，否则为false，且默认为false，即没有被选过
     * @param path 用于存储每一次递归后产生的一个结果，如【1,1,2】
     */
    //整体思路和代码和入门版相同，主要是要去重，只需加上一个判断条件即可
    public void backtrack(int[] nums, ArrayList<Integer> path, boolean[] visited){
        //5.1递归结束的条件
        if(path.size() == nums.length){
            result.add(new LinkedList(path));//每递归一次后就把该结果存入结果集中。
            return ;
        }

        //5.2选择列表,即从第一个数字开始遍历，很简单
        for(int i = 0; i<nums.length; i++){
            // 1）开始排除不合法的选择（重点）
            // 我们已经选择过的不需要再放进去了
            if(visited[i])//若该值为真，则表示已经选过了，则不再选它，跳过即可
                continue;
            //如果当前节点等于他的前一个节点，并且他的前一个节点已经被遍历过了，那我们也就不需要了。
            if(i>0 && nums[i] == nums[i-1] && visited[i-1])
                break;//也可以使用continue，但是不如break来的直接，break是直接跳出这一块，而continue则是一次一次地跳出。
            //2）做出选择，即把当前数字存入list中
            path.add(nums[i]);
            //同时把该值设为已经被使用过（重点）
            visited[i] = true;
            //3）再开始下一轮递归/回溯
            backtrack(nums,path,visited);
            //最后，撤销选择，即把最后那个数字删除，同时设为false，即设为未被使用过的状态，因为在下一轮时，该值还是可以使用的。
            //我们的目的是使得同一层循环不能出现已经被使用过的数字，而对于其他层是不要求的，
            //即[1,1,2]和[1,2,1]是可以的（只是元素重复，但是是两种不同的结果，都符合题目要求），
            //但是[1,1,2]和[1,1,2]就是重复的（结果重复）。
            path.remove(path.size()-1);
            visited[i] = false;
        }
    }
}