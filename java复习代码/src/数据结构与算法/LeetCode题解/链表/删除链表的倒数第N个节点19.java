package 数据结构与算法.LeetCode题解.链表;

import 数据结构与算法.LeetCode题解.ListNode;

/**
 * 19. 删除链表的倒数第N个节点
 * 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
 *
 * 示例：
 * 给定一个链表: 1->2->3->4->5, 和 n = 2.
 * 当删除了倒数第二个节点后，链表变为 1->2->3->5.
 *
 * 说明：
 * 给定的 n 保证是有效的。
 *
 * 进阶：
 * 你能尝试使用一趟扫描实现吗？
 */

/**
 * 思路解析：有三种方法：
 * （1）方法1：属于普通方法，即先计算原链表长度，再顺序遍历找到倒数第n个节点并删除。（但使用了两次扫描）
 *      1）通过一次遍历得到原链表的长度 len 。
 *      2）第二次遍历找到原链表第 len - n + 1 个节点（也就是倒数第n个节点）删除。
 *
 * （2）方法2：使用快慢指针：（推荐，只使用了一次扫描）
 *      1) 定义快慢两个指针，首先先指向pre节点，再将快指针先指向第 n + 1 个节点，使得快慢指针之间相差 n 个节点。
 *      2) 此时，再让快慢指针一起向后遍历，则易知，当快指针遍历完原链表时，慢指针指向的下一个节点刚好就是要删除的节点，于是将其删除即可。
 *
 * （3）方法3：使用递归
 *      1) 遍历每个节点，递归返回当前节点的下一个节点。
 *      2) 从最后一个节点返回开始计数，当要返回的节点为第 n 个则删除当前节点。
 *
 */
//方法1：普通方法，计算原链表长度，再找到目标节点并删除(掌握）
class 删除链表的倒数第N个节点19_1 {
        public ListNode removeNthFromEnd(ListNode head, int n) {
            //1.先定义一个新节点(一般叫预节点）用来指向结果链表的头节点head。
            ListNode pre = new ListNode(0);
            //2.将新节点指向当前链表的头节点。
            pre.next = head;
            //3.定义长度 len 来记录原链表的长度。
            int len = 0;
            //3.1定义一个 p 指针从头结点head遍历链表，每有一个节点则长度 +1 。
            ListNode p = head;
            while (p != null) {
                len++;
                p = p.next;
            }
            //4.倒数第 n 个节点就是正数 len - n 的下一个节点。
            len -= n;
            p = pre;//即令p从预节点开始遍历
            //4.1遍历原链表找到第 len - n 个节点，并删除它的下一个节点。
            for (int i = 0; i < len; i++) {//注意：此时的len=原len - n
                p = p.next;//循环结束后，p指向第 len - n 个节点
            }
            //4.2删除原链表第 len - n 的下一个节点（即指针跳过该节点）。
            p.next = p.next.next;
            //5.最终，按照题目的要求，返回头结点即可，也就是预节点的下一个节点
            return pre.next;//注意：为什么不直接使用head节点返回呢？因为有可能链表只有一个节点1，且此时若还要删除一个节点，
            // 那么删除之后，链表为空，此时如果还返回链表的头结点1的话，则显然是错误的，
            // 因此只能使用预节点来指向头结点，易知，此时它的下一个节点为空，返回的也就是空，符合题意。
        }
}

//方法2：双指针（掌握）
class Solution19_2 {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //1.定义一个新节点（即预节点）用来指向结果链表的头节点。
        ListNode pre = new ListNode(0);
        //2.将新节点指向当前链表的头节点。
        pre.next = head;
        //3.再定义快慢两个指针，先都指向pre节点，用来找到倒数第 n 个节点。
        ListNode fast = pre;
        ListNode slow = pre;
        //4.再遍历链表将快指针指向第 n + 1 个节点，使得快慢指针之间相差 n 个节点，再令快慢指针一起向后遍历。
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
            if (i == n) {
                //4.1此时快指针已经在第n+1个位置了，再令快慢指针一起向后遍历，
                // 易知当快指针遍历到原链表的最后一个节点时，慢指针指向的下一个节点刚好就是要删除的节点。
                while (fast != null) {
                    fast = fast.next;
                    slow = slow.next;
                }
            }
        }
        // 4.2于是用慢指针删除倒数第 n 个节点即可。
        slow.next = slow.next.next;
        return pre.next;
    }
}

//方法2：递归(理解即可）
class Solution19_3 {
    // 记录倒数节点数。
    int nums;
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 递归结束的条件：如果节点为空，直接返回并初始化计数器为 0 。
        if(head == null){
            nums = 0;
            return null;
        }
        // 递归遍历每个节点的下一个节点。
        head.next = removeNthFromEnd(head.next,n);
        // 从最后一个节点开始倒数计数。（因为上述递归式会一直递归到链表的最后节点才开始向上一级返回结果，也就是说递归的结果是从最后一个节点开始的，
        // 因此可以从最后一级计算的时候开始计数，当返回到倒数第n个节点的结果时，此时就把该节点删除，也即使得该处的结果指向其下一个节点，即head.next即可）
        nums++;
        // 数到倒数第 n 个节点，则删除当前节点，返回倒数第 n - 1 个节点。
        if(nums == n) {
            return head.next;
        }
        return head;
    }
}