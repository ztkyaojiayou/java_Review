package 数据结构与算法.LeetCode题解.动态规划;

/**
 *
 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组
 （该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 示例 1:
 输入: [2,3,-2,4]
 输出: 6
 解释: 子数组 [2,3] 有最大乘积 6。

 示例 2:
 输入: [-2,0,-1]
 输出: 0
 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
 */

/**
 * 动态规划
 * 第 1 步：状态设计（特别重要）
 * dp[i][j]：以 nums[i] 结尾的连续子数组的最值，计算最大值还是最小值由 j 来表示，j 就两个值；
 * 当 j = 0 的时候，表示计算的是最小值；
 * 当 j = 1 的时候，表示计算的是最大值。
 * 这样一来，状态转移方程就容易写出。
 *
 * 第 2 步：推导状态转移方程（特别重要）
 * 由于状态的设计 nums[i] 必须被选取（请大家体会这一点，这一点恰恰好也是使得子数组、子序列问题更加简单的原因：
 * 当情况复杂、分类讨论比较多的时候，需要固定一些量，以简化计算）；
 * nums[i] 的正负和之前的状态值（正负）就产生了联系，由此关系写出状态转移方程：

 * 当 nums[i] > 0 时，由于是乘积关系：
 * 最大值乘以正数依然是最大值；
 * 最小值乘以同一个正数依然是最小值；
 * 当 nums[i] < 0 时，依然是由于乘积关系：
 * 最大值乘以负数变成了最小值；
 * 最小值乘以同一个负数变成最大值；
 * 当 nums[i] = 0 的时候，由于 nums[i] 必须被选取，最大值和最小值都变成 0 ，合并到上面任意一种情况均成立。
 * 但是，还要注意一点，之前状态值的正负也要考虑：例如，在考虑最大值的时候，当 nums[i] > 0 时，如果 dp[i - 1][1] < 0 （之前的状态最大值） ，
 * 此时 nums[i] 可以另起炉灶（这里依然是第 53 题的思想），此时 dp[i][1] = nums[i] ，合起来写就是：
 *
 * dp[i][1] = max(nums[i], nums[i] * dp[i - 1][1]) if nums[i] >= 0
 * 其它三种情况可以类似写出，因此状态转移方程如下：
 *
 * dp[i][0] = min(nums[i], nums[i] * dp[i - 1][0]) if nums[i] >= 0
 * dp[i][1] = max(nums[i], nums[i] * dp[i - 1][1]) if nums[i] >= 0
 *
 * dp[i][0] = min(nums[i], nums[i] * dp[i - 1][1]) if nums[i] < 0
 * dp[i][1] = max(nums[i], nums[i] * dp[i - 1][0]) if nums[i] < 0
 *
 * 第 3 步：考虑初始化
 * 由于 nums[i] 必须被选取，那么 dp[i][0] = nums[0]，dp[i][1] = nums[0]。
 *
 * 第 4 步：考虑输出
 * 题目问连续子数组的乘积最大值，这些值需要遍历 dp[i][1] 获得。
 */
public class 乘积最大子数组152 {

        public int maxProduct(int[] nums) {
            //0.特判
            int len = nums.length;
            if (len == 0) {
                return 0;
            }

            //1.定义一个与状态方程相关的二维数组（第二个变量只设置两个值true和false），其中：
            //dp[i][0]：以 下标i 结尾的连续子数组的最小值
            //dp[i][1]：以 下标i 结尾的连续子数组的最大值
            int[][] dp = new int[len][2];

            //2.确定初始情况
            dp[0][0] = nums[0];//即以 下标0 结尾的连续子数组的最小值，即第一个元素的值
            dp[0][1] = nums[0];//即以 下标0 结尾的连续子数组的最大值，即第一个元素的值

            //3.再考虑一般情况，使用状态方程，先把这个二维数组填满
            for (int i = 1; i < len; i++) {//下标从1开始即可
                if (nums[i] >= 0) {//当为正数时
                    //即：以 下标i 结尾的连续子数组的最小值 = 取“以下标 i-1 （即前一个）
                    // 结尾的连续子数组的最小值和当前遍历值（正）的乘积” 和 “当前遍历值”中的较小值
                    //因为有可能相乘之后还没有当前遍历值小
                    dp[i][0] = Math.min(nums[i], nums[i] * dp[i - 1][0]);
                    //同理可得
                    dp[i][1] = Math.max(nums[i], nums[i] * dp[i - 1][1]);
                } else {//当为负数时，则相反，即当前值要乘以以前一个下标结尾的子数组的最大值才得到最小值
                    //即：以 下标i 结尾的连续子数组的最小值 = 取“以下标 i-1 （即前一个）
                    // 结尾的连续子数组的最大值和当前遍历值（负）的乘积” 和 “当前遍历值”中的较小值
                    //因为有可能相乘之后还没有当前遍历值小
                    dp[i][0] = Math.min(nums[i], nums[i] * dp[i - 1][1]);
                    //同理可得
                    dp[i][1] = Math.max(nums[i], nums[i] * dp[i - 1][0]);
                }
            }

            //4.再到这个已经填满了的数组中找我们需要的真正的最大值，遍历并取最大值即可
            int result = dp[0][1];//只关心最大值，则不需要管最小值了
            for (int i = 1; i < len; i++) {
                result = Math.max(result, dp[i][1]);
            }
            return result;
        }
    }
