package 数据结构与算法.LeetCode题解.动态规划;

import java.util.Arrays;

/**
 * （入门级121）买卖股票的最佳时机 I：只可交易一次，即只能买卖一只股票
 * 给定一个数组，它的第 i 个元素（从1开始数）是一支给定股票第 i 天的价格。
 * 如果你最多只允许完成一笔交易（即只能买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
 * 注意：你不能在买入股票前卖出股票。
 *
 * 示例 1:
 * 输入: [7,1,5,3,6,4]
 * 输出: 5
 * 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
 *      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
 *
 * 示例 2:
 * 输入: [7,6,4,3,1]
 * 输出: 0
 * 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 */

//方法1：(只需一层循环，而暴力破解则需要两层循环）（推荐）
//(1) 通过记录买入时机循环一层，每次比较是否有更合适的买入时机记录。
//(2) 不是更合适的买入时机则计算更新当前记录的最大利润。
//也即：遍历数组，用min_price记录价格的当前最低值，并不断更新，min_price = min (min_price，当前价格)；
//用max_profit 记录当前的最大利润，并不断更新,max_profit = max(max_profit , 当前价格 - min_price).
class 入门级121 {
        public int maxProfit(int[] nums) {
            //0.特判
            if (nums.length == 0)
                return 0;
            //1.1记录最大利润
            int max_profit = 0;
            //1.2记录买入时机，初始化为第一天的值，
            int min_price = nums[0];//由于数组的索引是从0开始的，因此这里写0，而不是1。
            //2.开始遍历数组
            for (int i = 1; i < nums.length; i++){
                //2.1若当天价格小于等于买入时价格，则记录当天为买入时机。
                if(nums[i] <= min_price){
                    min_price = nums[i];
                }else {
                    //2.2否则，若当天价格大于买入时，则比较记录最大利润。
                    max_profit = Math.max(nums[i] - min_price, max_profit);
                }
            }
            return max_profit;//3.返回结果即可
        }
    }

//方法2：动态规划(没太懂）
/**
 * 动态规划的 5 个步骤：
 *
 * 1、设定状态
 * 这道题其实是一个典型的二维 dp 问题。“动态规划”用于多阶段最优化问题的求解。
 * 这里天数代表每个阶段，即一天一天看，设置为第一维。
 * 为了消除后效性（前面的状态确定下来以后不会因为后面状态而更改），将当天是否持股设置为第二维的状态。
 * 于是：状态 dp[i][j] 表示：在索引为 i 的这一天，用户手上持股状态为 j 所获得的最大利润。
 * 说明：
 * j 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。
 * “用户手上不持股”不代表用户一定在索引为 i 的这一天把股票抛售了；

 * 2、思考状态转移方程
 * 2.1 dp[i][0] 怎样转移？
 * dp[i - 1][0] ：当然可以从昨天不持股转移过来，表示从昨天到今天什么都不操作，这一点是显然的；
 * dp[i - 1][1] + prices[i]：昨天持股，就在索引为 i 的这一天，我卖出了股票，状态由 1 变成了 0，此时卖出股票，因此加上这一天的股价。
 * 综上：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
 *
 * 2.2 dp[i][1] 怎样转移？
 * dp[i - 1][1] ：昨天持股，今天什么都不操作，当然可以从昨天持股转移过来，这一点是显然的；
 * -prices[i]：注意：状态 1 不能由状态 0 来，因为事实上，状态 0 特指：“卖出股票以后不持有股票的状态”，请注意这个状态和“没有进行过任何一次交易的不持有股票的状态”的区别。
 * 因此，-prices[i] 就表示，在索引为 i 的这一天，执行买入操作得到的收益。注意：因为题目只允许一次交易，因此不能加上 dp[i - 1][0]。
 * 综上：dp[i][1] = max(dp[i - 1][1], -prices[i]);
 *
 * 3、考虑初始值
 * 第 0 天不持股，显然 dp[0][0] = 0；
 * 第 0 天持股，显然dp[0][1] = -prices[0]。
 *
 * 4、考虑输出
 * 从状态转移方程可以看出，每一天的状态都考虑了之前的状态。在只发生一次交易的情况下，持有这支股票一定不能使我们获得最大利润。
 * 因此输出是 dp[len - 1][0]，不可能是持股的状态 dp[len - 1][1]，
 */
class Solution121 {

    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }

        // 0：用户手上不持股所能获得的最大利润，特指卖出股票以后的不持股，非指没有进行过任何交易的不持股
        // 1：用户手上持股所能获得的最大利润

        // 注意：因为题目限制只能交易一次，因此状态只可能从 1 到 0，不可能从 0 到 1
        int[][] dp = new int[len][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }
        return dp[len - 1][0];
    }
}

/**
 * (进阶版122）买卖股票的最佳时机 II：可交易多次，
 * 即可以买卖多只股票，但必须是一只股票先卖出，才能再买新股票继续交易（另外，肯定不能买之前已经交易过了的股票了啊，
 * 即假如你在第三天卖出了自己的股票，则下一只股票只能买当天的或明天以后的了）
 *
 * 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
 * 设计一个算法来计算你所能获取的最大利润。（区别）你可以尽可能地完成更多的交易（既可以多次买卖一支股票）。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 * 示例 1:
 * 输入: [7,1,5,3,6,4]
 * 输出: 7
 * 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
 *      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
 *
 * 示例 2:
 * 输入: [1,2,3,4,5]
 * 输出: 4
 * 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
 *      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
 *      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
 *
 * 示例 3:
 * 输入: [7,6,4,3,1]
 * 输出: 0
 * 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 */

/**
 * 解法：使用贪心算法，更好理解（当然，也可以使用动态规划）
 * 股票买卖策略：只加正数。
 * 有以下三种情况：
 （1）单独交易日:设今天价格p1、明天价格p2，则今天买入、明天卖出可赚取金额p2 -p1 (负值代表亏损)。
 （2）连续上涨交易日:设此上涨交易日股票价格分别为:1.P....Pn，则第一天买，最后一天卖收益最大，即Pn- P1;
 等价于每天都买卖，即Pn-p1=(p2-p1)+(p3-p2)+...+(Pn-Pn-1)。（这种理解太妙啦，因为刚好题目要求可以多次交易，则可以每天都买，每天都卖）
 （3）连续下降交易日:则不买卖收益最大，即不会亏钱。

 * 算法流程：（思路太TM清晰啦）
 * 遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。
 * 设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1] ；
 * 当该天利润为正 tmp > 0，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过；
 * 遍历完成后，返回总利润 profit。
 * 复杂度分析：
 *
 * 时间复杂度 O(N)： 只需遍历一次price；
 * 空间复杂度 O(1)： 变量使用常数额外空间。
 */
class 进阶版122 {
    public int maxProfit(int[] nums) {
        int maxProfit = 0;//所求的最大利润
        for (int i = 1; i < nums.length; i++) {
            int cur_profit = nums[i] - nums[i - 1];//表示当天的利润（可能为负）
            //若当天的利润为正 tmp > 0，则将该天的利润加入总利润 profit；当利润为 0 或为负，则直接跳过；
            if (cur_profit > 0) {
                maxProfit += cur_profit;
            }
        }
        return maxProfit;
    }
}


/**
 *  (进阶版309）最佳买卖股票时机含冷冻期：可进行多次交易，但卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)
 * 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
 * 设计一个算法计算出最大利润。在满足以下约束条件下，（区别1）你可以尽可能地完成更多的交易（多次买卖一支股票）:
 * 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 * （区别2）当天卖出股票后，你无法在第二天买入股票 (即冷冻期/间隔期为 1 天)。
 *
 * 示例:
 * 输入: [1,2,3,0,2]
 * 输出: 3
 * 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
 */
    /**
     * 我们用 f[i] 表示第 i 天结束之后的「累计最大收益」。
     * 根据题目描述，由于我们最多只能同时买入（持有）一支股票，
     *
     * 并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：
     * 1）我们目前持有一支股票，对应的「累计最大收益」记为f[i][0]；
     * 2）我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；
     * 3）我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。
     *
     * 这里的「处于冷冻期」指的是在第 i 天结束之后的状态。
     * 也就是说：如果第 i天结束之后处于冷冻期,那么第 i+1 天无法买入股票。
     *
     * 对这三种状态进行分析:
     *
     * 1）对于 f[i][0]，有两种情况，
     * 1.1我们目前持有的这一支股票可以是在第i−1 天就已经持有的，对应的状态为 f[i−1][0]；
     * 1.2或者是第 i 天买入的，那么第 i−1 天就不能持有股票并且不处于冷冻期中，
     * 对应的状态为 f[i−1][2] ,再加上买入股票的负收益prices[i]。因此状态转移方程为：
     * f[i][0]=max(f[i−1][0],f[i−1][2]−prices[i])
     *
     * 2）对于 f[i][1]，我们在第 i 天结束之后处于冷冻期的原因是在当天卖出了股票，
     * 那么说明在第 i−1 天时我们必须持有一支股票
     * （不然拿什么卖呢？要注意的是，这里说的持有一只股票不代表一定是当天买的股票，
     * 也有可能是之前买了还没卖的股票），对应的状态为 f[i−1][0] ,
     * 加上卖出股票的正收益prices[i]。因此状态转移方程为：
     * f[i][1]=f[i−1][0]+prices[i]
     *
     * 3）对于 f[i][2]，我们在第 i 天结束之后不持有任何股票并且不处于冷冻期，
     * 说明当天没有进行任何操作，即第i−1 天时不持有任何股票，于是有两种情况：
     * 如果处于冷冻期，对应的状态为 f[i−1][1]；
     * 如果不处于冷冻期，对应的状态为 f[i−1][2]。
     * 因此状态转移方程为（取收益最大的即可）：
     * f[i][2]=max(f[i−1][1],f[i−1][2])
     *
     * 这样我们就得到了所有的状态转移方程。如果一共有 n 天，那么最终的答案即为：
     * max(f[n−1][0],f[n−1][1],f[n−1][2])
     *
     * 注意到如果在最后一天（第 n-1n−1 天）结束之后，手上仍然持有股票，那么显然是没有任何意义的。
     * 因此更加精确地，最终的答案实际上是 f[n−1][1] 和 f[n−1][2] 中的较大值，即：
     * max(f[n−1][1],f[n−1][2])

     */
    class Solution309 {
        public int maxProfit(int[] nums) {
            if (nums.length == 0) {
                return 0;
            }
            int len = nums.length;
            // dp[i][0]: 第i天手上持有股票的最大收益
            // dp[i][1]: 第i天手上不持有股票，并且处于冷冻期中的累计最大收益
            // dp[i][2]: 第i天手上不持有股票，并且不在冷冻期中的累计最大收益
            int[][] dp = new int[len][3];
            dp[0][0] = -nums[0];
            for (int i = 1; i < len; ++i) {
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - nums[i]);
                dp[i][1] = dp[i - 1][0] + nums[i];
                dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]);
            }
            return Math.max(dp[len - 1][1], dp[len - 1][2]);
        }
    }


    /**
     * （高阶版123）买卖股票的最佳时机 III：可交易两次(但不是多次）
     *
     * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
     * 设计一个算法来计算你所能获取的最大利润。（区别）你最多可以完成 两笔 交易。
     * 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
     *
     * 示例 1:
     * 输入: [3,3,5,0,0,3,1,4]
     * 输出: 6
     * 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     *      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
     *
     * 示例 2:
     * 输入: [1,2,3,4,5]
     * 输出: 4
     * 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     *      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     *      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
     *
     * 示例 3:
     * 输入: [7,6,4,3,1]
     * 输出: 0
     * 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
     */

/**
 *解法：模拟真实交易
 * 在一定的天数内，我们最多可以进行两次交易，分为 买-卖-买-卖，所以问题的关键就是找到这4个点的最优分布
 * 回到本方法，核心的思想就是：
 * 第一次买入 / 第一次卖出 / 第二次买入 / 第二次卖出 这四个过程都可能发生在今天！（关键）
 * 先看一个例子：
 *
 * 我手上有10元，以下四步都在一天/今天完成：
 * 第一次买入花了2元， 利润/成本为 -2 元
 * 第一次卖出，卖了4元，利润为 4-2 = 2 元
 * 第二次买入，花了3元，剩余利润为 2-3 = -1 元
 * 第二次卖出，卖了5元，最终利润为 -1 + 5 = 4 元
 * 所以下面我们就定义了4个变量与上述4个过程对应：
 *
 * 第一次买入后的状态： minPrice1: 最低价格
 * 第一次卖出后的状态： maxProfit1: 第一次交易最大利润
 * 第二次买入后的状态： maxProfitAfterBuy: 第二次买入后的最大剩余利润
 * 第二次卖出后的状态： maxProfit2: 当天最终能获得最大最大利润
 * (注意，上述四个步骤是连贯的）
 *
 * 然后遍历每一天，在每一天我们都作 4个假设，并更新上面4个状态；
 * 1.假设今天第一次买入：更新 最低价格
 * 2.假设今天第一次卖出：更新 第一次最大利润
 * 3.假设今天第二次买入：更新 第二次买后的最大剩余利润
 * 4.假设今天第二次卖出：更新 当天最终能获得的最大利润
 *
 * 其中，如何理解 maxProfitAfterBuy ？ 即： 第二次买入后的最大剩余利润
 * 比如：今天我第一次卖出股票利润为5元，明天价格为2元，后天价格为3元
 * 你在哪天第二次买？你当然在明天啊，因为成本低，这样第二次买入后你手上的剩余利润就越大，
 * 这样往后你就只需要找哪天价格最高卖出去就行了，因为这个时候，你卖多少钱，你的总利润就相当于多了多少！
 * 当然后面还有可能价格有1元的，所以这个 maxProfitAfterBuy 也是不停的更新

 */
class 高阶版123 {
        public int maxProfit(int[] prices) {
            int minPrice1 = Integer.MAX_VALUE;//最低价格，初始化为最大值
            int maxProfit1 = 0;//第一次交易最大利润
            int maxProfitAfterBuy = Integer.MIN_VALUE;//第二次买入后的最大剩余利润,初始化为最小值
            int maxProfit2 = 0;//(第二次后）当天最终能获得最大最大利润
            for (int price : prices) {//遍历每一天的股票价格，更新上述四个状态值
                // 1.第一次最小购买价格（使用当前价格和之前的最小值比较，
                //取最小值即可，即保证该值永远是最小的）
                minPrice1 = Math.min(minPrice1, price);

                // 2.第一次卖出的最大利润（即以当前的最小价格卖出取得的利润，
                // 同时要和之前的该值比较，取最大值即可，即保证该值永远是最大的）
                maxProfit1 = Math.max(maxProfit1, price - minPrice1);

                // 3.第二次购买后的剩余净利润（此时就是以当前股票的价格买入，看还剩多少净利润；
                // 同样，要和之前的该值比较并取最大值，也即保证该值永远是最大的）
                maxProfitAfterBuy = Math.max(maxProfitAfterBuy, maxProfit1 - price);

                // 4.第二次卖出后，总共获得的最大利润（第3步的净利润 + 第4步卖出的股票钱；此时也是以当前股票价格卖出；
                // 当然，也同样要和之前的该值比较并取最大值，以保证该值永远是最大值）
                maxProfit2 = Math.max(maxProfit2, price + maxProfitAfterBuy);
            }
            //5.最后，返回第二次卖出后的利润值maxProfit2即为所求
            return maxProfit2;
        }
    }


/**
 * （高阶版188）买卖股票的最佳时机 IV：可以完成 k 笔交易（了解即可）
 * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
 * 设计一个算法来计算你所能获取的最大利润。（区别）你最多可以完成 k 笔交易。
 * 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 *
 * 示例 1:
 * 输入: [2,4,1], k = 2
 * 输出: 2
 * 解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
 *
 * 示例 2:
 * 输入: [3,2,6,5,0,3], k = 2
 * 输出: 7
 * 解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
 *      随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
 */

/**
 * 解法：使用动态规划
 * 我们的目标是求解最大利润，其中有两个状态属性：「交易最大次数k」和「天数n」。当天面临的选择也很简单：「不做处理」和「卖出股票」，暂时先不考虑何时买入的问题。
 * 我们定义dp[k + 1][n]，元素dp[i][j]表示最多交易i次时在第j天能获得的最大利润。dp[i][j] = max(不做处理， 卖出股票)
 * 如果不做处理，第j天的最大利润就和第j-1天相等。
 * 如果卖出股票，设是在第m天买入，那么第j天的最大利润就是两天的价格差+最多交易i-1次时第m天的获利。当然，这里的m需要从0遍历到j-1。
 *
 * 当k >= n / 2时，可退化为无限次交易的问题，即题122
 * 空间复杂度也可以继续优化，因为我们在考虑最多进行i次交易时，只用到了dp[i-1]的数据，所以可以只需要保存两行。空间复杂度可以优化成O(n)O(n)。
 */
class Solution188 {
    public int maxProfit(int k, int[] prices) {
        if(prices == null || prices.length == 0) return 0;
        int n = prices.length;

        if(k >= n/2){//此时相当于可以进行多次交易
            int profit = 0;
            for(int i = 1; i < n; i++){
                if(prices[i] > prices[i-1]){
                    profit += prices[i] - prices[i-1];
                }
            }
            return profit;
        }

        int[][] dp = new int[k + 1][n];
        for (int i = 1; i < dp.length; i ++){
            int maxDiff = -prices[0];
            for (int j = 1; j < dp[0].length; j ++){
                maxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j]);
                dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);
            }
        }
        return dp[k][n - 1];
    }
}
