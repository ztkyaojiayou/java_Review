package 数据结构与算法.LeetCode题解.动态规划;

import java.util.Arrays;

/**
 * 322. 零钱兑换
 * 给定不同面额的硬币 coins 和一个总金额 amount。
 * 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
 * 如果没有任何一种硬币组合能组成总金额，返回 -1。

 * 示例 1:
 * 输入: coins = [1, 2, 5], amount = 11
 * 输出: 3
 * 解释: 11 = 5 + 5 + 1
 *
 * 示例 2:
 * 输入: coins = [2], amount = 3
 * 输出: -1
 * 解释：因为无法凑出
 *
 * 说明:
 * 你可以认为每种硬币的数量是无限的。
 */

/**
 * 方法：使用动态规划：自底向上
 * 即先使总金额从1开始（则易知，只需要遍历总金额amount即可），
 * 先计算出凑成金额1需要的最少银币数
 * （则易知，直接遍历一遍硬币面值，一个一个试，取其中的最小值即可，
 * 但前提是凑成该面值的硬币要比该值要小，否则肯定凑不了嘛，这里在代码中加一个判断即可）
 * 再计算金额2需要的最少银币数，此时就可以转化到 “凑成金额1需要的最少银币数 + 1”来解决，
 * 这里的1表示使用凑成金额1需要的最少银币数再加上一个面值为1（被减去的那个硬币值）的硬币即可凑成金额2（每一步都是这样）
 * 以此类推，直到计算出金额11需要的最少银币数。
 *
 * 使用例子说明，通俗易懂：
 * 假设 coins = [1, 2, 5], amount = 11。
 * 则当 i==0 时无法用硬币组成，为 0 。当 i<0 时，忽略 F(i)
 *
 * F(i)	最小硬币数量
 * F(0)	0 //金额为0不能由硬币组成
 * F(1)	1 //F(1)=min(F(1-1),F(1-2),F(1-5))+1=1
 * F(2)	1 //F(2)=min(F(2-1),F(2-2),F(2-5))+1=1
 * F(3)	2 //F(3)=min(F(3-1),F(3-2),F(3-5))+1=2
 * F(4)	2 //F(4)=min(F(4-1),F(4-2),F(4-5))+1=2
 * ...	...
 * F(11)	3 //F(11)=min(F(11-1),F(11-2),F(11-5))+1=3
 */
public class 零钱兑换322 {

    //动态规划求解
    public int coinChange(int[] coins, int amount) {
            //先定义一个数组
        int[] dp = new int[amount + 1];//dp[i] 表示凑成总金额为i所需的最少的硬币个数
        //再确定初始条件
        dp[0] = 0;
        for (int i = 1; i <= amount; i++)
            dp[i] = amount + 1;//对后面的每个元素都初始化为 amount + 1，表示不可能凑出来的情况（只要设置成大于amount即可）
        //Arrays.fill(dp, amount + 1);//骚操作，直接填充

        for (int i = 1; i <= amount; i++) {//对总金额开始拆解，先从金额1开始
            for (int j = 0; j < coins.length; j++) {//对于每一个金额i，它都可能有所有的硬币面值凑出，因此需要对硬币面值做一次遍历，一个一个试
                if (coins[j] <= i) {//但前提是硬币面值要小于当前金额，否则怎么凑嘛（1块零钱怎么用2块钱的硬币凑？半个？）
                    //状态方程，即当前金额为i所需的最少的硬币个数 = 减去一个硬币后所剩下的金额所需的最少硬币数 + 1（被减去的那个硬币值coins[j]）
                    //当然，这里还需要和之前的dp[i] 继续比较，使得该值永远是最小值，所以这里用了min（）
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);// 当确定了一个硬币时，就把总金额i - 当前硬币值，剩下的金额继续如此
                }
            }
        }
        //返回结果即可（主要凑不了的情况）
        return dp[amount] > amount ? -1 : dp[amount];
    }
}


