package 数据结构与算法.LeetCode题解.动态规划;
/**
 * 416. 分割等和子集
 * 给定一个只包含正整数的非空数组。
 * 是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
 *
 * 注意:
 * 每个数组中的元素不会超过 100
 * 数组的大小不会超过 200
 *
 * 示例 1:
 * 输入: [1, 5, 11, 5]
 * 输出: true
 * 解释: 数组可以分割成 [1, 5, 5] 和 [11].
 *
 * 示例 2:
 * 输入: [1, 2, 3, 5]
 * 输出: false
 * 解释: 数组不能分割成两个元素和相等的子集.
 */

/**
 * 整体分析：
 * 本题其实就是背包问题换了一种问法而已，即原题可以表述为：
 * 给定集合A，能否从A中挑选多个数，其和为 sum/2。
 *
 * 定义dp数组：dp[i][j]表示在背包载重最大为j的情况下，对前i个物品进行选择，所能装的最大价值。
 * 例如：dp[3][4] 就表示在背包载重（这里就是sum/2)最大为4的情况下，在前3个物品（这里就是数组中的元素）中进行选择后所能装的最大价值。
 * 回到我们的0-1背包问题中，我们最终想要的到的就是dp[n][sum/2]。
 *
 * （1）0-1背包问题
 * 本题是一道0-1背包的动态规划题目。首先在这里介绍一下0-1背包问题。
 * 假设现在有1个背包和N个物品。背包的最大载重为w。每个物品有两个属性：重量和价格。
 * 第i个物品的重量为w[i]，价值为p[i]。问这个背包最多能装多少价值的东西？
 * 这是典型的动态规划问题。对于上述的物品来说，只有两个状态:"不放进背包（0）"和“放进背包（1）”。所以这种一般都称为0-1背包问题。
 * 按照之前大佬所说的框架第一步要明确状态与选择。
 * 状态：对背包而言，背包的重量，背包能够选择的物品
 * 选择：对物品而言，选择物品放进背包或不放进背包
 * 然而，动态规划就是在某种状态下做出最优的选择。
 *
 * 接下来需要定义dp数组。
 * 定义dp数组：dp[i][j]表示在背包载重最大为j的情况下，对前i个物品进行选择，所能装的最大价值。
 * 例如：dp[3][4] = 5表示在背包载重最大为4的情况下，在前3个物品中进行选择后，所能装的最大价值为5。
 *
 * 回到我们的0-1背包问题中，我们最终想要的到的就是dp[n][sum/2]。
 *
 * 初始情况为:
 * dp[0][⋯]=0，表示在各种背包载重的情况下，在前0个物品中进行选择（也就是没有物品可选），所以最大价值为0.
 * dp[⋯][0]=0，表示在背包载重为0的情况下，对于前任意物品选择，也都放不进去。所以最大价值为0。
 *
 * （2）本题题解
 * 解释完0-1背包问题后，回到本题，要求分割成两个等和的子集。
 * 乍一看好像没有什么动态规划的思路。但我们换一种说法，能不能找出和为数组总和一半的子集。
 * 这就相当给你一个背包的最大载重量为数组总和的一半，对于N个元素，能不能正好放进去。
 *
 * 这里我们定义dp数组：
 * dp[i][j]表示 在载重量为j的情况下，如果前i个元素能够将背包放满，则dp[i][j] = true,如果不能够放满，则dp[i][j] = false。
 *
 * 那我们最终要求的就是dp[n][sum/2]。
 *
 * 明确这个定义后我们就转换为了动态规划问题，我们可以按照下的流程写了。
 * 计算数组的和sum，如果sum为奇数，那肯定不能分成两部分，直接返回false；
 * 如果sum为偶数，按照上面的0-1背包框架声明dp数组。
 * 初始化 :dp[⋯][0]=true，相当于当载重量为0的时候，肯定什么东西也不用放，背包肯定默认是满的，因为载重量为0嘛，所以是true；
 * dp[0][⋯]=false,相当于在任一载重量时，什么东西都不放，那肯定背包没有满，所以是false。
 * 接下来按照0-1背包框架进行推算。
 */
public class 分割等和子集416 {
        public boolean canPartition(int[] nums) {
            int sum = 0;
            //0.特判：
            //计算数组的和sum，如果sum为奇数，那肯定不能分成两部分，直接返回false
            for(int i = 0; i<nums.length; i++) sum += nums[i];
            if(sum % 2 != 0)
                return false;

            int target = sum/2;
            //1.先创建一个二维数组，其中，dp[i][j]表示在总和最大为j的情况下，对前i个元素进行选择并装入后是否可以装满的状态，即true或false。
            boolean[][] dp = new boolean[nums.length+1][target+1];

            //2.再确认初始情况
            //2.1当目标（载重量）j为0时，此时什么元素都不用放，默认就可以构成/装满，所以是true；
            for(int i = 0; i<nums.length+1; i++)
                dp[i][0] = true;
            // 2.2当没有元素可以选择时，则不管目标j为多少都不可能构成/装满，所以是false
            // 这里可以省略，因为java中boolean量默认是false，这里没有注释掉是因为想把逻辑表达清楚。
            for(int i = 0; i<target+1; i++)
                dp[0][i] = false;

            //3.再看一般情况，使用状态方程即可
            for(int i = 1; i<=nums.length; i++){//下标i从1开始即可（因为0为初始情况），表示可选的元素依次增加，从数组的第一个元素开始，在此情况下
                for(int j = 1; j<=target; j++){//目标j从1开始慢慢增加，计算出小问题，再计算大问题，直到sum/2
                    //如果要放的数量比当前的背包容量都大，那就没法放，只能维持之前的状态
                    if(j < nums[i-1]) {
                        dp[i][j] = dp[i-1][j];
                    } else{
                        //否则，就可以放入了，但也可以不放入，不管哪种状态，只要能放满就行
                        //（1）dp[i-1][j]：就表示不放入，而是维持之前的状态
                        //（2）dp[i-1][j-nums[i-1]]：就表示放入，即在背包载重最大为j-nums[i-1]的情况下（因为已经放了nums[i-1]了嘛），
                        //对前i-1个物品进行选择，所能装的最大价值
                        dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                    }
                }
            }
            //最后，返回所求结果即可
            return dp[nums.length][target];//即在背包载重最大为target的情况下，对数组中的所有元素进行选择，所能装的最大价值。
        }
    }
