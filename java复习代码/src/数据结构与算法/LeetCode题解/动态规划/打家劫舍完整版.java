package 数据结构与算法.LeetCode题解.动态规划;

/**
 * （1）入门版
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
 * 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
 * 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 * 给定一个代表每个房屋存放金额的非负整数数组，
 * 计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
 *
 * 示例 1:
 * 输入: [1,2,3,1]
 * 输出: 4
 * 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
 *      偷窃到的最高金额 = 1 + 3 = 4 。
 *
 * 示例 2:
 * 输入: [2,7,9,3,1]
 * 输出: 12
 * 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
 *      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
 */

import javax.swing.tree.TreeNode;
import java.util.Arrays;

/**
 * 解法：动态规划
 *
 * 考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。
 * 记：f(k) = 从前 k 个房屋中能抢劫到的最大数额，A（i）= 第 i 个房屋的钱数。
 * 首先看 n = 1 的情况，显然 f(1) = A（1）
 * 再看 n = 2，易知，此时就有两种情况了，即抢第一个房子或者抢第二个房子，找那个最大的房子抢即可，因此有：f(2) = max(A（1），A（2））
 * 而对于 n = 3，则同样地，也有两个选项:
 * （1）若抢第三个房子，则还可以抢第一个房子，但不可抢第二个房子，则总金额就为第三个房子的金额与第一个房子的金额相加。
 * （2）若不抢第三个房子，则保持抢前两个房子的最大数额（此时就可以抢第二个房子）。
 *
 * 显然，我们再从这两种情况中选较大值即可，则以此类推，可以总结出如下递推公式/状态方程：
 * f(k) = max(f(k – 2) + A（k）, f(k – 1))；其中f(k – 2)表示从前“与当前房子间隔一个房子的位置处的房子”中能抢劫到的最大数额
 *
 *
 * 再看初始状态：
 * 我们选择 f(–1) = f(0) = 0 为初始情况，这将极大地简化代码。
 *
 * 而我们要求的答案即为 f(n)。可以用一个数组来存储并计算结果。不过由于每一步你只需要前两个最大值，两个变量就足够用了。
 */
class 打家劫舍入门版198 {
    public int rob(int[] nums) {
        //0.特判：数组长度为0和1时（则后面只需从2开始即可）
        if (nums.length == 0) {
            return 0;
        }
        //1.定义一个与状态方程相关的一维数组，其中，dp[i] 表示 从前 i 个房屋中能抢劫到的最大数额，
        //则所求结果即为 dp[dp.length - 1]（因为索引从0开始）
        int[] dp = new int[nums.length];
        //2.再确定初始值，即当长度为1和为2时，至于结果，前面已经分析过了。
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        //3.再看一般情况，使用状态方程化为初始情况即可
        for (int i = 2; i < nums.length; i++) {//下标从2开始即可
            dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
        }
        //4.获取所求结果并返回即可
        return dp[dp.length - 1];
    }
}

/**
 * （2）进阶版：
 * 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
 * （与入门版的区别来啦）这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。
 *
 * 同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
 *
 * 示例 1:
 * 输入: [2,3,2]
 * 输出: 3
 * 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
 *
 * 示例 2:
 * 输入: [1,2,3,1]
 * 输出: 4
 * 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
 *      偷窃到的最高金额 = 1 + 3 = 4 。
 */

/**
 * 总体思路：
 * 此题是 198.打家劫舍 的拓展版： 唯一的区别是此题中的房间是环状排列的（即首尾相接），而 198题中的房间是单排排列的；而这也是此题的难点。
 * 环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：
 * (1)在不偷窃第一个房子的情况下（即nums[1:length)），最大金额是 p1；
 * (2)在不偷窃最后一个房子的情况下（即 nums[0:length-1)），最大金额是 p2。
 *
 * 再综合偷窃最大金额：易知，即为以上两种情况的较大值，即 max(p1,p2)。
 * 即：其实就是做两次198题的动态规划，一次是[0,n-2]，一次是[1,n-1]，再取二者中的较大值即可
 */
class 打家劫舍进阶版213 {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        //要用到Arrays.copyOfRange(T[ ] original,int from,int to)方法
        //其作用是：将原始数组original，从下标from开始复制，复制到上标to，生成一个新的数组。且新数组中包括下标from，但不包括上标to。
        return Math.max(rob198(Arrays.copyOfRange(nums, 0, nums.length - 1)),
                rob198(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    //再直接调用入门版的方法即可
    private int rob198(int[] nums) {
        //0.特判：数组长度为0和1时（则后面只需从2开始即可）
        if (nums.length == 0) {
            return 0;
        } else if (nums.length == 1) {
            return nums[0];
        }
        //1.定义一个与状态方程相关的一维数组，其中，dp[i] 表示 从前 i 个房屋中能抢劫到的最大数额，
        //则所求结果即为 dp[dp.length - 1]（因为索引从0开始）
        int[] dp = new int[nums.length];
        //2.再确定初始值，即当长度为1和为2时，至于结果，前面已经分析过了。
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        //3.再看一般情况，使用状态方程化为初始情况即可
        for (int i = 2; i < nums.length; i++) {//下标从2开始即可
            dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
        }
        //4.获取所求结果并返回即可
        return dp[dp.length - 1];
    }
}

/**
 * （高阶版）在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。
 * 这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。
 * 一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。
 *
 * （区别）如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
 * 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
 *
 * 示例 1:
 * 输入: [3,2,3,null,3,null,1]
 *
 *      3
 *     / \
 *    2   3
 *     \   \
 *      3   1
 *
 * 输出: 7
 * 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
 *
 * 示例 2:
 * 输入: [3,4,5,1,3,null,1]
 *
 *      3
 *     / \
 *    4   5
 *   / \   \
 *  1   3   1
 *
 * 输出: 9
 * 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
 *
 */

/**
 * 解法：初读题目发现题目相当于树形结构的动态规划，从题目本身来讲，我们一般是要进行以下两个选择：
 *
 * （1）若不偷当前节点，则两个儿子节点都要给出最多的钱
 * （2）若偷当前节点，则不能偷其两个儿子节点
 * 至此，我们可以对每个节点定义有一个长度为2的数组
 *
 * int[] node = new int[2];
 * 其中下标0表示不偷，下标1表示偷。那么对于以上情况能得到最多的钱就应该表示为：
 *
 * （1）不偷当前节点所能获得的最大收益 = 左儿子所能获得的最大收益 + 右儿子所能获得的最大收益
 * （2）偷当前节点所能获得的最大收益 = 偷当前节点的钱 + 不偷左儿子所获得的钱 +不偷右儿子所获得的钱
 * 其中“儿子所能获得最大收益为：max（偷当前儿子所能获得最大收益，不偷当前儿子所能获得最大收益）”。
 *
 * 则易知，所求结果即为：max(情况1所能获得的最大收益,情况2所能获得的最大收益)
 */
 //Definition for a binary tree node.
 class TreeNode337 {
      int val;
      TreeNode337 left;
     TreeNode337 right;
 TreeNode337(int x) { val = x; }
  }

  class 打家劫舍高阶版337 {
    public int rob(TreeNode337 root) {
        //countSum(root)的作用就是计算当前节点偷与不偷所能获得收益，结果存在数组result中，
        //且这里的当前节点可以通过递归的方式来计算器其左右节点对应的值
        int[] result = countSum(root);//这个result数组的结果就来自于dp数组
        //根据题意可知需取其中最大的
        return Math.max(result[0],result[1]);
    }

    public int[] countSum(TreeNode337 root){
        //1.先定义一个数组，其中：
        //dp[0] 表示不偷当前节点时所能获得的最大收益
        //dp[1] 表示偷当前节点时所能获得的最大收益
        int[] dp = new int[2];
        //2.再确定初始值
        //如果当前节点为空节点，则其结果为0
        if(root == null){
            return dp;
        }
        //3.计算当前节点左节点和右节点（偷与不偷）所能获得的收益（利用递归的思想）
        int[] left = countSum(root.left);
        int[] right = countSum(root.right);

        //4.考虑一般情况，要用到状态方程，由上面的分析知，有如下两种情况：
        //4.1当不偷当前节点时所能获得的最大收益 = 左儿子所能获得的最大收益（同样地，又分为偷或不偷当前节点） + 右儿子所能获得的最大收益（同样地，也又分为偷或不偷当前节点）
        dp[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        //4.2当偷当前节点时所能获得的最大收益= 偷当前节点的钱 + 不偷左节点所获得的钱 +不偷右节点所获得的钱
        dp[1] = root.val+left[0]+right[0];//left[0]就表示不偷左节点所获得的钱，right[0]同理。

        //5.返回结果值，即这个数组
        return dp;
    }
}
