package 数据结构与算法.LeetCode题解.动态规划;

/**
 * 一个机器人位于一个 m列 x n行的网格的左上角 （起始点在下图中标记为“Start” ）。
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
 * 问总共有多少条不同的路径？
 *
 *例如，上图是一个7 x 3 的网格。有多少可能的路径？
 * 示例 1:
 * 输入: m = 3, n = 2
 * 输出: 3
 * 解释:
 * 从左上角开始，总共有 3 条路径可以到达右下角。
 * 1. 向右 -> 向右 -> 向下
 * 2. 向右 -> 向下 -> 向右
 * 3. 向下 -> 向右 -> 向右
 *
 * 示例 2:
 * 输入: m = 7, n = 3
 * 输出: 28 
 *
 * 提示：
 * 1 <= m, n <= 100
 * 题目数据保证答案小于等于 2 * 10 ^ 9
 */

//典型的动态规划题,简单：
//思路：到达某一点的路径数 = 到达该位置上面一格的路径数 + 到达该位置左边一格的路径数
//假设当前站在[i,j]处，那你上一步是在[i-1,j]处向下走到达当前位置或者从[i,j-1]处向右走到达当前位置。和爬楼梯的思想是一致的。
public class 到达对角位置的不同路径的总条数62 {
        public int uniquePaths(int m, int n) {//m是行，n是列
            int[][] dp = new int[m][n];//定义一个m行n列的二维数组/矩阵，其中每一个值表示到达该位置的总路径
            //再找边界情况，即第一行和第一列
            for(int i=0;i<n;i++){
                dp[0][i]=1;//即到达第一行的任何位置的路径都只有一条，即只有直走嘛（又不能先向下再向上）
            }
            for(int i=0;i<m;i++){
                dp[i][0] = 1;//同理，即到达第一列的任何位置的路径都只有一条，即只有直走嘛（又不能先向右再向左）
            }
            //一般情况，使用状态方程转化为初始/边界状态求解（核心）
            for(int j=1;j<n;j++){//都是先一列一列地从1开始纵向填写/遍历，因为大问题需要用到这些值
                for(int i=1;i<m;i++){
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];//dp[i][j]表示到达位置坐标（i，j）的路径总条数（此时不需要求最小值，因为不是求最短路径,见题64）
                }
            }
            return dp[m-1][n-1];//返回最右下角的位置的值，即为所求（数组的索引是从0开始的）
        }
    }
