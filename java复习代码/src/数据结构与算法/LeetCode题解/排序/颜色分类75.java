package 数据结构与算法.LeetCode题解.排序;

/**
 * 75. 颜色分类(这就是著名的荷兰国旗问题）
 * 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，
 * 使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
 * 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
 *
 * 注意:
 * 不能使用代码库中的排序函数来解决这道题。
 *
 * 示例:
 * 输入: [2,0,2,1,1,0]
 * 输出: [0,0,1,1,2,2]
 *
 * 进阶：
 * 一个直观的解决方案是使用计数排序的两趟扫描算法。
 * 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
 * 你能想出一个仅使用常数空间的一趟扫描算法吗？
 */

/**
 * 思路解析：只需用三个指针（left, right 和cur）来分别表示当前元素的最左边界，最左边界和当前位置本身。
 * 然后利用cur指针从数组的头部开始遍历，其对应的值有如下三种情况：
 * 1）若nums[cur] = 0，则将其与 nums[left]互换（注意：只是把其对应的值互换，而指针的位置并没有互换，下同），
 *    使得0始终位于1的左边，同时向前移动当前指针和左指针（cur++，left++）；
 * 2）若nums[cur] = 1，则向前移动当前指针（cur++），即就把1放在当前位置不动；
 * 3）若 nums[cur] = 2 ，则将其与 nums[right]互换，使得2始终位于1的右边，
 *    同时向后移动right指针（right--），因为right指针的当前位置已经被处理过啦。
 * 4）直到当前指针cur > right,算法结束。
 */
public class 颜色分类75 {
    public void sortColors(int[] nums) {
        int len = nums.length;//数组长度
        //0.特判
        if (len < 2) {
            return;
        }
        //1.定义和初始化三个指针
        int left = -1;//定义左边索引位置
        int right = len - 1;//定义右边索引位置
        int cur = 0;//定义当前移动索引指针
        //2.开始利用当前指针cur从头开始遍历数组
        // 直到当前指针cur的位置超过右指针right的位置
        while (cur <= right) {
            //2.1如果当前访问元素是0，left右移，交换，cur也右移
            if (nums[cur] == 0) {
                left++;//要将一开始定义的-1变成0
                swap(nums, cur, left);//交换
                cur++;//右移
                //2.2如果当前访问元素是1，则该元素不动，只需将cur右移，处理下一个元素即可
            } else if (nums[cur] == 1) {
                cur++;//右移
            } else {//2.3如果当前访问元素是2，则应该把它放在最右边，
                // 因此只需：和最右边的的元素互换，同时处理倒数第二个位置，即right左移即可
                swap(nums, cur, right);
                right--;//左移
            }
        }
    }

    //两个元素交换的具体实现
    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
