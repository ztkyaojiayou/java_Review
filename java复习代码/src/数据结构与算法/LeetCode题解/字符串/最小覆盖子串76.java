package 数据结构与算法.LeetCode题解.字符串;

/**
 * 76. 最小覆盖子串
 * 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 的所有字符的最小子串。
 *
 * 示例：
 * 输入: S = "ADOBECODEBANC", T = "ABC"
 * 输出: "BANC"
 *
 * 说明：
 * 如果 S 中不存这样的子串，则返回空字符串 ""。
 * 如果 S 中存在这样的子串，我们保证它是唯一的答案。
 */

/**
 * 思路解析：滑动窗口（思路简单，但细节很烦）
 * （1）滑动窗口的思想：
 *     先寻求一个可行的解
 *     在可行解的基础上，优化这个可行解
 *     优化到不能优化，产生出一个可能的最优解
 *     继续寻求新的可行解
 *     继续优化这个可行解
 *     ……
 *     在可能的最优解中产生出最优解

 * (2)本题详解：
 *    1)本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。
 *
 *    2)我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。
 * 一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。
 * 在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。
 * 当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。
 *
 *   3)如何判断当前的窗口包含所有 t 所需的字符呢？
 * 我们可以用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，
 * 如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，
 * 那么当前的窗口是「可行」的。
 *
 * (3)复杂度分析
 *    1）时间复杂度：最坏情况下左右指针对 s 的每个元素各遍历一遍，哈希表中对 s 中的每个元素各插入、删除一次，对 t 中的元素各插入一次。
 * 每次检查是否可行会遍历整个 t 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 C，
 * 则渐进时间复杂度为 O(C⋅∣s∣+∣t∣)
 *    2）空间复杂度：这里用了两张哈希表作为辅助空间，每张哈希表最多不会存放超过字符集大小的键值对，
 * 我们设字符集大小为 C ，则渐进空间复杂度为 O(C)。
 *
 * 参考链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/
 */
public class 最小覆盖子串76 {
        public String minWindow(String s, String t) {
            //1.特判
            if (s == null || t == null || s.length() == 0 || t.length() == 0) return "";
            //2.定义一个数组，用来记录字符串 t 中出现字符的频率，
            //也就是窗口内需要匹配的字符和相应的频率（因为需要匹配的字符串可能有重复）
            //和使用hashMap做哈希映射相同，这里就是使用字符作为下标，用其值作为频率/出现的次数
            int[] map = new int[128];
            for (char c : t.toCharArray()) {//把目标字符串t转化为字符数组是为了便于处理
                map[c]++;
            }
            //3.定义变量
            //3.1定义两个用于移动滑动窗口的指针，先均置于滑动窗口的最左端
            int left = 0, right = 0;
            //3.2匹配到的字符的个数（而不是频率，因此需要匹配到的个数应为目标字符串的长度）
            int match = 0;
            //3.3最大的子串的长度，用来记录符合条件的最短子串长度，初始化为超出字符串 s 。
            int minLen = s.length() + 1;
            //3.4子串的起始位置和结束的位置，用于截取符合题目要求的子串
            // (如果不存在这样的子串的话，start，end 都是 0，s.substring 截取就是 “”）
            int start = 0, end = 0;

            //4.开始移动滑动窗口，结束条件是：右指针到了字符串的最右端
            //让右指针开始向右滑动，不断扩大滑动窗口，使得滑动窗口中包含了目标字符串t
            while (right < s.length()){
                //4.1先处理第一个位置（因为right指针一开始指向第一个位置嘛）
                char charRight = s.charAt(right); // 右边界的那个字符

                // 即先入为主，先假设目标字符串t中包含该字符，即需要匹配该字符，因此将其频率减一，因为：
                // 1）若字符 charRight 在 t 中存在，那很理想，说明这是一次有意义的匹配，则我们就需要将其频率减1，
                // 同时由于此时map[charRight] >= 0肯定成立，于是再将“匹配到的字符的个数”match加1。
                // 2）而若字符 charRight 不在 t 中，那么执行 map[charRight]-- 之后，会小于 0, 则不进行任何操作，也符合我们的逻辑。
                map[charRight]--;
                if (map[charRight] >= 0){
                    match++;
                }
                //4.2再使右指针右移，这样下面就变成了 [)，方便计算窗口大小
                right++;

                //4.3当窗口内匹配的字符达到了要求，此时即已经找到了一个可行解，
                // 但还不一定是最优解，即可能还不是最短的子串，于是固定右边界，收缩左边界（即让左指针右移，移除左边的元素）
                // 注意：只有窗口内匹配的字符达到了要求才会进入此循环
                while (match == t.length()){
                    int size = right - left;//当前窗口长度
                    if (size < minLen){
                        //4.3.1更新窗口长度为当前窗口的长度，同时更新子串的两个端点
                        minLen = size;
                        start = left;
                        end = right;
                    }
                    //4.3.2先处理最左边那个字符，该字符可能是目标串t中的字符，也有可能不是，
                    // 我们也同样先入为主，先假设它是字符串t中的字符，这样，下面的代码是符合逻辑的
                    char charLeft = s.charAt(left);  // 左边的那个字符
                    // 左边的字符要移出窗口
                    // 1）若该字符不属于 t 中出现的字符，则移出窗口，最终能够达到的最大值 map[charLeft] = 0，此时不需要做任何处理
                    // 2）而若该字符属于 t 中出现的字符，恰好移出了需要匹配的一个字符，那么执行map[charLeft]++之后， map[charLeft] > 0,
                    // 也就是还要通过右指针右移来在此匹配字符charLeft，此时把已经匹配的字符match减1即可
                    // （每移除一个，就减1，即表示还需要右指针再次匹配到目标字符串的长度t.length())
                    map[charLeft]++;
                    if (map[charLeft] > 0) {
                        match--;
                    }
                    //4.3.3左边界收缩，直到移出了需要匹配的一个字符，接下来就又要使右指针右移啦
                    left++;
                }
            }
            //5.最终，返回最短的子串即可
            return s.substring(start, end);
        }
}
