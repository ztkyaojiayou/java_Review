package 数据结构与算法.LeetCode题解.数组;

/**
 * 287. 寻找重复数
 * 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），
 * 可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
 *
 * 示例 1:
 * 输入: [1,3,4,2,2]
 * 输出: 2
 *
 * 示例 2:
 * 输入: [3,1,3,4,2]
 * 输出: 3
 *
 * 说明：
 * 不能更改原数组（假设数组是只读的）。
 * 只能使用额外的 O(1) 的空间。
 * 时间复杂度小于 O(n2) 。
 * 数组中只有一个重复的数字，但它可能不止重复出现一次。
 */

/**
 * 解题思路：使用双指针，把其看成环形链表问题（剑指offer上有一道类似的题）
 * 我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，
 * 根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，
 * 此时，我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。
 *
 * 详解：关键是要理解如何把该数组变为一个链表？
 * 其实就是把下标（从0开始，但本代码中，我们令链表从第一个元素开始，
 * 即把第一个元素的值作为链表的第一个元素，接着就以该值作为下一个连接节点的下标）当值，
 * 再去连接该数组中由该值作为下标的对应的值，以此类推即可。（非常关键）
 *
 * 使用环形链表II的方法解题（142.环形链表II），使用 142 题的思想来解决此题的关键是要理解如何将输入的数组看作为链表。
 * 首先明确前提，整数的数组 nums 中的数字范围是 [1,n]。考虑一下两种情况：
 * (1)如果数组中没有重复的数，以数组 [1,3,4,2]为例，我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，
 * 其映射关系 n->f(n)为：
 * 0->1
 * 1->3
 * 2->4
 * 3->2
 * 我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。这样可以产生一个类似链表一样的序列。
 * 0->1->3->2->4->null
 *
 * (2)如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，
 * 其映射关系 n->f(n) 为：
 * 0->1
 * 1->3
 * 2->4
 * 3->2
 * 4->2
 * 同样的，我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。
 * 0->1->3->2->4->2->4->2->……
 * 综上所述：
 * 1.数组中有一个重复的整数 <==> 链表中存在环
 * 2.找到数组中的重复整数 <==> 找到链表的环入口
 * 至此，问题就完全转换为了 环形链表问题。那么针对此题，快、慢指针该如何走呢？
 * 根据上述数组转链表的映射关系，可推出：
 * 142 题中慢指针走一步 slow = slow.next ==> 本题 slow = nums[slow]
 * 142 题中快指针走两步 fast = fast.next.next ==> 本题 fast = nums[nums[fast]]
 *
 */
//推荐版本
public class 寻找重复数287 {
    public int findDuplicate(int[] nums) {
        // 定义快慢指针遍历数组，都从0开始。
        int slow = 0, fast = 0;
        // 从头开始通过元素值指向下一个元素位置，慢指针走一步，快指针走两步。
        do {
            // 双指针从 0 位置开始，先执行一次循环，直到找到相遇位置跳出循环。
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        // 找到相遇位置后将慢指针移到起点位置。
        slow = 0;
        // 快慢指针分别从相遇位置和起点重新出发每次走一步，直到下次相遇跳出循环。
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        // 返回第二次循环的相遇位置。
        return slow;
    }
}

//版本2，思路一模一样，但在定义快慢指针的时候总感觉不太好理解
class Solution287 {
    public int findDuplicate(int[] nums) {
        // 1.定义快慢指针遍历数组（总感觉不太懂）
        int slow = nums[0];//慢指针指向第一个位置
        int fast = nums[nums[0]];//快指针则指向慢指针的下一个位置
        //2.寻找相遇点，慢指针走一步，快指针走两步。直到找到相遇位置就跳出循环。
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } //3.找到相遇位置后，再令slow 从起点出发, fast 从相遇点出发, 一次都只走一步
        //直到下次相遇跳出循环,返回该位置即可，即为所求。
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }// 返回第二次循环的相遇位置，即为所求。
        return slow;
    }
}
