package 数据结构与算法.LeetCode题解.贪心算法;

import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

/**
 * 406. 根据身高重建队列
 * 假设有打乱顺序的一群人站成一个队列。
 * 每个人由一个整数对(h, k)表示，其中h是这个人的身高，
 * k是排在这个人前面且身高大于或等于自己身高h的人数，
 * （即比它高的人必须站前面，这也是我们需要按照身高降序排列的原因）。
 * 编写一个算法来重建这个队列，即按照k来对h排序，使得排出来的顺序符合k值。
 *
 * 注意：
 * 总人数少于1100人。
 *
 * 示例
 * 输入:
 * [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
 *
 * 输出:（即当把身高按照[5,7,5,6,4,7]排列时，就刚好符合k的意义，
 * 比如[5,2]，其表示前面比它高或相同的人有2个，
 * 易知，按照现在这样排序的话，正好是符合的，其中一个身高是5，另一个是7）
 * [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
 */

/**
 * 解法：也叫贪心？？？
 * 理解1：根据每一步最优规则（在每种身高条件下，根据k排序），
 * 达到每一步最优（这里就是每一大步排序完，目标队列是唯一的最优的），
 * 并且结果也是最优的 简单来说就是一步一步地根据可遵循地最优规律来执行全过程
 *
 * 理解2：（精髓）个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。
 * 高个子的人可以忽略矮个子的人，即每个人的插入位置只与比自己高的人相关，
 * 所以可以想到，先按身高由高到低排序再依次插入，这样刚好满足贪心的无后效性。
 * 然后每一次插入时，p[1]值刚好是插入序号，这个位置是对当前人来说最正确的决策，
 * 即局部最优。全部插入完毕则形成全局最优。
 *
 * 具体思路：
 * （1）先排序，规则：按高度降序排列，当高度相同时，按 k 值的升序排列。
 * （2）再逐个把它们放在输出队列中，其存放的位置索引值就等于它们的 k 值，
 *      这里要注意：每次插入时，只管从队列的前面往后面数，要加入的人的索引值k为多少，就往该位置上插入该人。
 *      若该索引1处已经有人了，那么下次再来一个1怎么办？此时下次来的这个人就替换他，之前的那个人往后移一步即可。
 * （3）最后，返回输出队列即为所求。
 *
 * 示例：
 *  对于[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
 *  （1) 先按照上述规则排好序，结果为：[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]
 *  （2）再一个一个插入。
 *        // [7,0]
 *        // [7,0], [7,1]
 *        // [7,0], [6,1], [7,1]
 *        // [5,0], [7,0], [6,1], [7,1]
 *        // [5,0], [7,0], [5,2], [6,1], [7,1]
 *        // [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]
 */
public class 根据身高重建队列406 {
        public int[][] reconstructQueue(int[][] nums) {
            //先排序,使用的是Arrays.sort()方法，
            //但是要自己写一个比较器，因为Arrays.sort()默认是升序排列，且只能比较一项，而这里需要比较两项。
            Arrays.sort(nums, new Comparator<int[]>() {
                @Override
                public int compare(int[] o1, int[] o2) {
                    // 按照高度的降序排列，而若高度相同，则按照k值升序排列
                    return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
                }
            });
            //此时，数组nums已经按照指定的规则排好了序
                //定义一个输出list（后面再转成数组即可；那为什么不直接定义一个数组呢？因为数组是固定的，无法进行添加操作），开始把人往里面塞
            List<int[]> res = new LinkedList<>();
            //
            for(int[] num : nums){//表示按行遍历二维数组nums，即把该二维数组看成是由很多行构成的一维数组p，
                // 而该题中每一行p刚好代表一组值[h,k],则p[1]就代表每一行（一维数组）的第二个数，这里即为K值，把它当做索引插入到list的该索引处即可
                /**
                 * add(int index,E element)：用于在此列表中指定的位置index处插入指定的元素element。
                 * 若该位置处有元素，则往后移，且所有后续元素也都向后移（即在其索引中添加 1）。
                 */
                res.add(num[1], num);//p[1]:即为每一组值的k，p即为每一组值；把p这一组值插入到list的索引为p[1]的地方
            }
            int n = nums.length;//行数
            //转化成一个n行2列的数组输出，即为所求
            return res.toArray(new int[n][2]);
        }
    }
