package 数据结构与算法.LeetCode题解.二叉树;

/**
 * 104. 二叉树的最大深度
 *
 * 给定一个二叉树，找出其最大深度。
 * 二叉树的（最大）深度（即最大高度）为根节点到最远叶子节点的最长路径上的节点数。
 *
 * 说明: 叶子节点是指没有子节点的节点。
 *
 * 示例：
 * 给定二叉树 [3,9,20,null,null,15,7]，
 *
 *     3
 *    / \
 *   9  20
 *     /  \
 *    15   7
 * 返回它的最大深度 3 。
 */

 //Definition for a binary tree node.
 class TreeNode104 {
     int val;
     TreeNode104 left;
     TreeNode104 right;
     TreeNode104(int x) { val = x; }
  }

/**
 * 解析：使用递归即可
 * 思路分析：
 * （1）一棵树的最大深度，等于其左右子树二者中的最大深度加上根结点带来的深度1。递归的关系。
 * （2）当一个结点为null时，其深度为0。这就是递归的结束条件。
 * （3）遍历了树中所有节点，所以时间复杂度为O(n)，函数调用栈与树高成正比，
 *      在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，保持调用栈的存储将是 O(n)。
 *      但在最好的情况下（树是完全平衡的），空间复杂度将是O(log(n))。
 */
class 二叉树的最大深度104 {
    public int maxDepth(TreeNode104 root) {
        //递归结束的条件，当一个结点为null时，其深度为0。
        if (root==null){
            return 0;
        }
        int left = maxDepth(root.left);//获取左子树的深度（即找到里面的最大的高度）
        int right = maxDepth(root.right);//获取左子树的深度
        return Math.max(left,right)+1;//返回以某个节点为根节点的数的最大深度为max
        // （即等于其左右子树二者中的深度加上根结点自己带来的深度1）
        //return left>right? left+1: right+1;//骚操作写法，了解即可
    }
}

/**
 * 111. 二叉树的最小深度(整体思路相同，只是要多考虑一种情况）
 * 给定一个二叉树，找出其最小深度。
 * 最小深度（即最小高度）是从根节点到最近叶子节点的最短路径上的节点数量。
 *
 * 说明: 叶子节点是指没有子节点的节点。
 *
 * 示例:
 * 给定二叉树 [3,9,20,null,null,15,7],
 *     3
 *    / \
 *   9  20
 *     /  \
 *    15   7
 * 返回它的最小深度  2.
 */

/**
 * 解析：本题是 104 题求最大深度的相反题目
 * 思路：
 * 很多人写出的代码都不符合 1,2 这个测试用例，是因为没搞清楚题意。
 * 题目中已经明确说明：叶子节点是指没有子节点的节点，也就是说此时的 1（根节点）并不是叶子节点。
 * 题目问的是到叶子节点的最短距离，所以此时的结果应为2，而不是1，要单独拿出来考虑。
 *
 * 另外这道题的关键是搞清楚递归结束条件
 * 叶子节点的定义是当左孩子和右孩子都为 null 时叫做叶子节点
 * 当 root 节点左右孩子都为空时，返回 1
 * 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
 * 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值
 *
 * 相比之下除了递归求解左右子树的深度外，还需要考虑左右子树是否为空这个情况
 * 如果有为空的情况，则直接返回两者深度之和再加上根节点的 1
 * 若都不为空，则求两者最小深度再加上根节点即可。
 */
class Solution111 {
    public int minDepth(TreeNode104 root) {
        //1.结束递归的条件
        //1.1到了叶子节点
        if (root == null) {
            return 0;
        }
        // 2.左右子树分别递归求各自的最小深度
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        // 2.1处理特殊情况，即如果左右子树都为空或者有一方为空，则直接返回两者的深度 + 1即可
        // （1）若左右子树都为空，此时说明已经到达了叶子节点，则直接返回1（0+0+1）即可，
        //      这种情况可以和“一方为空”的情况合并，因此把这两种情况写在一起啦
        // （2）若只有一方为空，比如(1,2),此时其左右子树的深度中必有一个为0，
        //     也可以通过公式left +right + 1求出，即为2，而若按一般情况处理得话，其结果则为1，这是不对的。
        if (root.left == null || root.right == null) {
            return left + right + 1;
        }
        // 2.2处理一般情况
        // 即若都不为空，此时就选两者（本身就是最小深度啦）中较小的深度 + 1 即可
        return Math.min(left, right) + 1;
    }
}
