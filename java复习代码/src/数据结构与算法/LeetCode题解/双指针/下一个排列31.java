package 数据结构与算法.LeetCode题解.双指针;

import java.util.Arrays;
/**
 *31. 下一个排列
 * 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
 * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
 * 必须原地修改，只允许使用额外常数空间。
 *
 * 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
 * 1,2,3 → 1,3,2
 * 3,2,1 → 1,2,3
 * 1,1,5 → 1,5,1
 */

/**
 * (1)先读懂题意，这一步很关键：
 * 关于通过字典序找下一个值的解释：
 * 比如对于1,2,3来说，可以组成这样的字典序列表[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]，
 * 题目意思就是让我们找到题目给定的序列在这个字典序列中的位置处的下一个序列，
 * 比如若题给序列DS为[1,2,3]，则我们先把由这三个数组成的所有排列求出来，
 * 再按照升序排好顺序，这个顺序就是题目中的字典顺序的意思，
 * 然后，我们再找到[1,2,3]这个序列在字典序列中的位置，易知，它就在第一个位置，
 * 因此我们要求的结果就是他的下一个位置，即【1,3,2】,
 * 而如果题给的序列是字典序列中的最后一个序列，则我们就选字典序列中的第一个元素作为我们的结果即可。

 * (2)思路分析：
 * 要将一个数排列成下一个更大的数，改动高位数字，改变后的数一下就会变得很大，不是下一个更大的数。所以改动数字应该从低位开始。
 * 举几个例子：
 * 1）若一个数为1234。从低位开始，4是最低位，其右边没有数字与其交换。然后3，其右边有4比它大，二者交换就得到下一个更大的排列。
 * 2）若一个数为123654。从低位开始，4是最低位，其右边没有数字与其交换。然后5，其右边没有比它大的数，与4交换只会使得排列更小。
 * 然后考虑6，与5同理。然后考虑3，可以和后面的4交换得到下一个更大的排列。
 * 所以从低位开始的意义就是：
 * 从int i = nums.length - 2开始，如果nums[i] >= nums[i + 1]，说明其前一个元素更大，不做任何处理。
 * 这样递推只要nums[i] >= nums[i + 1]成立，说明nums[i]是目前最大的数字，与其右边的数字交换得到的都是更小的排列。
 * 当nums[i] < nums[i + 1]时，nums[i]右边的数字有比它大的了，但是为了保证找到下一个更大的排列而不是任意更大排列，
 * 还需要通过一个循环去找到其右边比nums[i]大的最小的那个数。
 * 从上一条中可以知道，nums[i]右边的元素是递减排列的，所以也只需要从右往左，找到第一个大于nums[i]的元素。
 * for(; j > i && nums[j] <= nums[i]; j --);内循环结束，j就是要用于交换的元素。
 * 交换完后，只保证了i这一位及其高位排列正确了，但是i的右边还是递减的数字，不是下一个最大的排列。
 * 例如上面的例子123654，交换后为124653，还需要将i右边变为升序（124356）。
 * 这里就是[i + 1, nums.length - 1]的子数组翻转，双指针可以完成，但是为了方便，直接排序吧Arrays.sort(nums, i + 1, nums.length);/
 * 如果一直没有元素满足nums[i] < nums[i + 1]，说明不存在下一个更大的排列，则将数字重新排列成最小的排列，直接库函数排序。
 *
 * 上述过程的交换是原地操作，库函数的排序为快排也是原地的。
 * 使用双指针完成数组翻转的话，时间复杂度是线性的。空间复杂度为O(1)O(1)的。
 */
public class 下一个排列31 {
    /**
     * 核心关键：
     * 1）定义两个指针i和j，一前一后，但都从后面往前面遍历，先固定前一个指针，让后一个指针向前遍历，一一比对二者的值
     * 2）若当前元素num[i]大于后面的元素num[j]，则说明当前元素就是目前最大的，不用做任何处理，
     * 易知，通过这样的规则，可以保证当前位置的后面的元素都是比自己小的；
     * 3）而若前面的元素小于后面的元素，就说明右边的该数字有比它大的了，
     * 而由刚才的分析可知，该元素就是后面的元素中唯一一个比当前元素大的元素，
     * 因此只要找到了右边第一个比当前元素大的元素，就把这两个元素互换即可，
     * 4）此时保证了当前位置i这一位及其高位排列正确了（最高位我们不用动，只需要动低位即可），
     * 但是此时，i的右边还是递减的数字，不是下一个最大的排列。例如上面的例子123654，交换后为124653，
     * 因此还需要将i右边变为升序（124356）（非常关键）。
     */
    public void nextPermutation(int[] nums) {
        //1.从后往前遍历,且指针i在前，而指针j在后
        //（即指针i的起始位置为倒数第二个位置，而指针j则在倒数第一个位置）
        for(int i = nums.length-2; i>=0; i--){//i从倒数第二个位置开始
            for(int j = nums.length-1; j>i; j--){//j则从倒数第一个位置开始
                if(nums[i] < nums[j]){//2.1若当前元素num[i]小于后面的元素num[j]，
                    // 此时掉换一下二者的位置，此时保证了当前位置i这一位及其高位排列正确了
                    swap(nums,i,j);
                    //2.2同时要把当前元素后面的元素进行升序排列，才能保证结果为下一个最大的排列
                    Arrays.sort(nums,i+1,nums.length);
                    return;//注意：由于本题只需在原数组上修改，因此不用返回结果数组，修改好就完事儿啦~
                }
            }
        }
        //如果没有找到，则把数组变成升序即可
        //（注意：由于本题只需在原数组上修改，因此不用返回结果数组，修改好就完事儿啦）
        Arrays.sort(nums);
    }

    //掉换nums[i]和nums[j]的位置
    void swap(int[] a, int i, int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
