package 数据结构与算法.剑指offer第一版.排序;

/**
 * 题目描述
 * LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...
 * 他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,
 * 嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,
 * 他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。
 * 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。
 * 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何，
 * 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。
 *
 * 简述：五张牌，其中大小鬼为癞子（即可代替成任何牌），其牌面为 0。判断这五张牌是否能组成顺子。
 */

import java.util.Arrays;

/**
 * 思路解析：
 * 解法1：
 * 首先是将大小王表示任意数字（可能有多个大小王），等价成0可以表示任意数字。
 * 也就是{0,2,3,5,6}会被看成是顺子。那么思路如下：
 * 1.对抽到的5张牌进行排序；
 * 2.找出0的个数；
 * 3.算出相邻数字的空缺总数；比如3和5之间相差2，必须要有1个0才行。相差3就得要有两个0
 * 4.如果0的个数大于等于空缺总数，说明连续，反之不连续；
 * 5.需要判断相邻数字是否相等，如果有出现相等，说明不是顺子。
 *   调用了系统的排序算法。排序不是本题的考察点，所以重点关注后面怎么实现。
 *
 * 解法2：（了解即可）
 * 有大佬使用TreeSet集合，很有意思，值得学习一下。
 * 不管是用什么数据结构，总是需要进行排序，
 * 连续的两张牌不能相同，也可以选择去重的数据结构。因此数据结构的选择不唯一。
 * 以TreeSet为例，0不用装进去，但是要统计0的次数count，在装给集合任意5个数的时候，集合的size肯定小于等于5。
 * 如果size+count等于5，说明此时要判断间断情况，看赖子是否能成功拼成顺子。
 * 如果size+count不等于5（[1,0,0,1,0]这种情况，count是3，size是1）,
 * 其实也可以说是size+count小于5的情况，因为不可能出现大于5（当时给TreeSet装元素的时候，一共就只准备了5个元素），
 * 这种情况下，就是出现了重复元素，因此是false。
 *  最巧的点在于，只需要判断TreeSet的最小和最大元素差值小于5，就可以连成顺子。
 * 因为集合中是非0的数字，如果差距太大，0的数量弥补不了差距，就形成不了顺子，所以这个判断是真的妙。
 */
public class 扑克牌顺子60 {
    public boolean isContinuous(int[] numbers) {
        //0.特判
        if (numbers.length < 5)
            return false;
        //1.先排序
        Arrays.sort(numbers);
        //2.统计癞子数量
        int cnt = 0;
        for (int num : numbers)
            if (num == 0)
                cnt++;

        //3.使用癞子去补全不连续的顺子
        //3.1排序后前cnt个全为0，因此只需从非0元素处（即下标为cnt的位置）
        // 开始判断是否有重复元素，并补齐不连续的位置即可
        for (int i = cnt; i < numbers.length - 1; i++) {
            if (numbers[i + 1] == numbers[i])//3.2若有重复，则肯定不是顺子，直接返回false即可。
                return false;
            //3.3再看癞子能否补全其不连续的位置，若补完之后还有剩余或刚好，则说明可以组成顺子，返回true即可。
            cnt -= numbers[i + 1] - numbers[i] - 1;
        }
        //3.4若补完之后还有剩余或刚好，则说明可以组成顺子，返回true即可。
        return cnt >= 0;
    }
}