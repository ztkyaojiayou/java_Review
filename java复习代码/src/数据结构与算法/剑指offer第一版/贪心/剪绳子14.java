package 数据结构与算法.剑指offer第一版.贪心;

/**
 * 题目描述
 * 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），
 * 每段绳子的长度记为k[0],k[1],...,k[m]。
 * 请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？
 * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 *
 * 输入描述:
 * 输入一个数n，意义见题面。（2 <= n <= 60）
 * 输出描述:
 * 输出答案。
 *
 * 示例1
 * 输入
 * 8
 * 输出
 * 18
 */

/**
 * 思路解析：(暴力）递归，动态规划和贪心（推荐）都可以实现。
 */

/**
 * 方法3：贪心算法（强烈推荐）
 * 尽量把大于5的数分解成3的乘积，如果剩下的长度为4，则把4分解成2和2，因为3 * 1 < 2 * 2。
 * 即尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
 * 如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
 *
 *     * 解题思路，找出最优解的规律
 *     * 当target等于1，2，3的时候，结果是固定的
 *     * 当target大于3的时候，可以看以下数据
 *     * target=4, 最优解：2 2
 *     * target=5, 最优解：3 2
 *     * target=6, 最优解：3 3
 *     * target=7, 最优解：3 2 2
 *     * target=8, 最优解：3 3 2
 *     * target=9, 最优解：3 3 3
 *     * target=10,最优解：3 3 2 2
 *     * target=11,最优解：3 3 3 2
 *     * target=12,最优解：3 3 3 3
 *     * target=13,最优解：3 3 3 2 2
 *     * target=14,最优解：3 3 3 3 2
 *     * target=15,最优解：3 3 3 3 3
 *     *
 *     * 所以不难发现3和2的个数规律，这和均值不等式有一定关系，具体证明略去。
 *
 * 证明：当 n >= 5 时，3(n - 3) - n = 2n - 9 > 0，且 2(n - 2) - n = n - 4 > 0。
 * 因此在 n >= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。
 * 又因为 3(n - 3) - 2(n - 2) = n - 5 >= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。
 */
class solution14_3 {
    public int cutRope(int target) {
        //0.特判，易知当target等于1，2，3的时候，结果是固定的。因为至少要分两段
        if (target < 2)
            return 0;
        if (target == 2)
            return 1;
        if (target == 3)
            return 2;

        //1.当 target > 3 时，就尽量把其分解成3的乘积，
        //并且不允许有长度为 1 的绳子出现，如剩下的长度为4，则把4分解成2和2，而不是3和1
        //1.1先求长度为3的绳子的段数，对3取商即可，很好求
        int timesOf3 = target / 3;

        //1.2若目标值只比3的倍数多1，则此时就会有长度为 1 的绳子出现，我们不允许有该绳子出现，而希望它以长度2的绳子出现，
        //于是我们可以从切好的长度为 3 的绳子中拿出一段（即长度为3的绳子的段数要减1）与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。
        if (target - timesOf3 * 3 == 1)
            timesOf3--;

        //1.3再求长度为2的绳子的段数，用剩下的长度对2取商即可
        int timesOf2 = (target - timesOf3 * 3) / 2;//2的段数(取商）

        //2.最后，求其乘积即可，易知此时就是多个3的乘积和多个2的乘积，使用Math.pow(a,b)即可:即求a的b次方。
        return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
    }
}

/**
 * 方法1：暴力递归（不推荐）
 *
 * 暴力递归就要想到递归三部曲：
 * 递归函数的设计和功能：back_track(n); 含义是：求长度为n的数，最后分段后的最大乘积，这里我们不需要关心分成多少段
 * 递归函数的终止条件: 如果n <= 4, 显然back_track(n) = n，初始条件也就是我们不用计算就能得到的。
 * 下一步递归：对于长度n，我们需要减少递归参数n，如果第一段为1，
 * 显然下一步递归为back_track(n-1),如果第一段为2， 则下一步递归为back_track(n-2)...
 * 因为要至少分2段，所以，最后一次可能的情况为最后一段为n-1, 下一步递归为back_track(1)，
 * 因此，每一步可能的结果为：1 * back_track(n-1), 2 * back_track(n-2), ..., (n-1) * back_track(1),
 * 在n-1种情况中取一个最大值即可。
 * 这里我们不用关系back_track(n-1)等的值为多少，因为最终会递归到我们的终止条件，因此绝对是可以求出来。
 */
class 剪绳子14_1 {
    public int cutRope(int target) {
        //调用递归，获取结果
        return cutRope(target, 0);
    }
            //具体的递归算法
            public int cutRope(int target, int max) {
                int maxValue = max;
                for(int i = 1; i < target; i++){
                    //即把剪绳子分为2步，先确定第一段的长度（这一段就有n-1种情况)，
                    //后面那段再使用递归继续分成两段，以此类推，直到初始位置
                    //再取这些值的最大值即可
                    maxValue = Math.max(maxValue, i*cutRope(target -i, target -i));
                }
                return maxValue;
    }
}

/**
 * 方法2：动态规划（推荐）
 * 接着上面的递归解法我们可以将其转换成动态规划的写法.
 * 由于这是一个从上至下的递归公式,递归会出现很多大量不必要的计算,
 * 一个很好的方法就是按照从下而上的顺序计算,即:
 * 我们先得到f(2),f(3),再得到f(4),f(5),直到f(n).
 * 我们可以得知f(2)=1, f(3)=2
 */
class solution14_2 {
    public int cutRope(int target) {
        int[] dp = new int[target + 1];
        dp[1] = 1;
        for (int i = 2; i <= target; i++)
            for (int j = 1; j < i; j++)
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
        return dp[target];
    }
}


