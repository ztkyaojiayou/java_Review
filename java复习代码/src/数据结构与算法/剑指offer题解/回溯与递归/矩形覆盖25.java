package 数据结构与算法.剑指offer题解.回溯与递归;

/**
 * 题目描述(最简单）
 * 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
 * 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
 */

/**
 * 思路解析：
 * 从特殊到一般，即先分析简单的，再一般化。
 *
 * n = 1 的时候
 * 只能横着覆盖，一种
 * n = 2 的时候
 * 可以横着和竖着覆盖，两种
 * n = 3 的时候
 * 第三级横着覆盖，用了一级，剩下 n = 2，有两种覆盖方法
 * 第三季竖着覆盖，用了两级，剩下 n = 1，有一种覆盖方法
 * 总共有 3 种
 * n = 4 的时候
 * 第 4 级横着覆盖，用了一级，剩下 n = 3，有三种覆盖方法
 * 第 4 级竖着覆盖，用了两级，剩下 n = 2，有两种覆盖方法
 * 总共有 5 种方法
 * n = n 的时候
 * 第 n 级横着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法
 * 第 n 级竖着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法
 * 总和为两种情况的总和
 *
 * 我们就再分析以下，从n=3到n=4，怎么来的呢？
 * 这里有2种情况：
 * 直接在n=3的情况下，再后面中添加一个竖着的。这个很显然成立，有3种情况
 * 然后横着的显然能添加到n-2的情况上，也就是在n=2后面，添加2个横着的。有2种情况
 * 通过以上分析，发现刚好和图中的个数一样。
 * 所以总结：f [n]表示2*n大矩阵 的方法数。
 * 可以得出：f[n] = f[n-1] + f[n-2]，初始条件f[1] = 1, f[2] =2
 *（就是个斐波拉契数列,和“爬楼梯_跳台阶”那一道题一模一样）
 * 所以代码可用递归，记忆递归，和动态规划和递推。
 */
public class 矩形覆盖25 {
    public int RectCover(int target) {//target为目标矩形的宽，也就代表者矩形的大小（就看成“爬楼梯”里面的总楼层数即可）
        //1.递归结束的条件
        if (target < 1) {
            return 0;
        } else if (target == 1 || target == 2) {
            return target;
        } else {//2.对于其他情况，使用递归即可
            return RectCover(target-1) + RectCover(target-2);
        }
    }
}
