package 数据结构与算法.剑指offer题解.位运算;

/**
 * 题目：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷四则运算符号。
 *
 * 【解】：
 *  不用加减乘除，那就只剩下位运算了
 *  回到了计算机中是如何做加法的：
 *      求 A + B
 *      while(B != 0){
 *          1. sum = A ^ B;            //sum就是表示在没有考虑进位的情况下两数的和
 *          2. carry = (A & B) << 1;  //carry即为其进位，只有A和B都是1时，才有进位
 *                                    //如果有进位，则sum与carry还要再异或一次。
 *          3. A = sum, B = carry
 *      }
 *
 * 举例说明：我们来做个2位数的加法
 * 计算11+01 = 100
 * 本来的算法
 * 11+01 = 100
 * 用推算的表达式计算
 * （1）11 ^ 01 = 10
 * （2）(11 & 01) << 1 = 10
 * 到这里 我们用普通的加法去运算这两个数的时候就可以得到 10 + 10 = 100,但由于我们不能加法，所以要想别的方法，如果让两个数再按刚才的算法计算一次呢？
 * 10 ^ 10 = 00
 * (10 & 10) << 1 = 100
 * 到这里基本上就得出结论了，其实后面的那个 “00” 已经不用再去计算了，因为第一个表达式就已经算出了结果。继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果。
 *
 * 总结
 * 计算机本质是二进制运算，乘法等问题解决的关键是如何用位运算实现加法。
 * 1：设a，b为两个二进制数，则a+b = a^b + (a&b)<<1。
 * 证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此(a&b)<<1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。
 * 2：使用定理1可以实现只用位运算进行加法运算。
 * 证明：利用定理1中的等式不停对自身进行迭代。每迭代一次，进位补偿右边就多一位0，因此最多需要加数二进制位长度次迭代，进位补偿就变为0，这时运算结束。
 * 3：一般采用递归实现，那么递归什么时候结束呢？
 * 由于(a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，当最后的进位会变为 0 时，递归终止。
 *
 *关于二进制下的四则运算，参见https://blog.csdn.net/WangQYoho/article/details/79688177
 */

//方法一：采用递归思想实现
    //写法1：把加数b同时看成进位
public class BitOperation63不用加减乘除做加法 {
    public int Add01(int a, int b) {//传入两个加数a和b
        //注意：再递归运算中，参数b已经不仅仅是加数，而且还是进位数，因此当b=0时说明已经没有进位了，则说明运算结束
        //利用三目运算符编写，代码非常简洁且易懂
        return b == 0 ? a : Add01(a ^ b, (a & b) << 1);
    }

//写法2：下面这个版本是上述版本的拆解版，更加通俗易懂
    public int add01(int a,int b){
        int sum,carry;
        sum=a^b;//不考虑进位，相加
        carry=(a&b)<<1;//进位
        //1.当没有进位时（即carry==0）则说明运算已完成
        if(carry==0) {
            return sum;
        }
        //2.否则，一直递归相加
        sum = add01(sum,carry);
        //3.返回sum即可
        return sum;
    }

//方法二：采用非递归方法实现
    //1.写法1：
    public int Add02(int a, int b){
        int sum = 0;
        int carry = 0;
        while (b != 0){//与方法一的写法1相同，把b看成进位
            sum = a ^ b;
            carry = (a & b) << 1;
            a = sum;
            b = carry;
        }
        return a;
    }

    //写法2：采用do...while语句，更加通俗易懂（推荐）
    public int add02(int num1,int num2) {
        int result = 0;
        int carry = 0;
        do{
            result = num1 ^ num2;       //不带进位的加法
            carry = (num1 & num2) << 1; //进位
            num1 = result;
            num2 = carry;
        }while(carry != 0); // 进位不为0则继续执行加法处理进位
        return result;
    }
}
