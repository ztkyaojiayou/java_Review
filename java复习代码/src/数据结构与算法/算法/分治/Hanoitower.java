package 数据结构与算法.算法.分治;

/**
 * 程序员必备的算法之（2）分治算法（其最佳实践就是汉诺塔（Hanoitower，不难）
 *思路：（1）先把原问题分解成若干个规模较小的相互独立的可以解决的子问题
 *     （2）再把各个可以解决的子问题的解合并为原问题的解即可
 *
 *汉诺塔移动要点：
 * （1）要求：把已经按从大到小的顺序放置在第一个柱子上的圆盘再按此顺序重新摆放到另外一个柱子上
 *          且在小圆盘上不能放置大圆盘，且在三根柱子之间一次只能移动一个圆盘
 * （2）方法：
 * 假设：三个柱子分别为：A B C,现在要把A柱子中的盘从A移动到C
 * 2.1如果只有一个盘，则直接移动过去即可
 * 2.2如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
 *    1）先把 最上面的所有盘 A->B， 移动过程会使用到 C
 *    2）把最下边的盘 A->C
 *    3）把B塔的所有盘 从 B->C , 移动过程使用到A塔
 */
public class Hanoitower {
//2.测试
    public static void main(String[] args) {
        hanoiTower(5, 'A', 'B', 'C');
    }

    //1.汉诺塔的移动的方法，使用分治算法，且需要用到递归
    public static void hanoiTower(int num, char a, char b, char c) {//目的：从a到c，b作为辅助
        //1.1如果只有一个盘
        if(num == 1) {
            System.out.println("第1个盘从 " + a + "->" + c);
        } else {
            //1.2如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘

            //1. 先把 最上面的所有盘 A->B， 移动过程会使用到 c,且并不是只有一步，这是一个递归，且这一步全部完成之后才进行下一步
            hanoiTower(num - 1, a, c, b);

            //2. 把最下边的盘 A->C，不需要递归，因为就是一步操作
            System.out.println("第" + num + "个盘从 " + a + "->" + c);

            //3. 把B塔的所有盘 从 B->C , 移动过程使用到 a塔，且并不是只有一步，这也是一个递归
            hanoiTower(num - 1, b, a, c);
        }
    }

}

